#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use serde::Serialize;
#[allow(dead_code, clippy::all)]
pub mod tangent {
    pub mod logs {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod log {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub enum Scalar {
                Str(_rt::String),
                Int(i64),
                Float(f64),
                Boolean(bool),
                Bytes(_rt::Vec<u8>),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Scalar {
                #[inline]
                fn clone(&self) -> Scalar {
                    match self {
                        Scalar::Str(__self_0) => {
                            Scalar::Str(::core::clone::Clone::clone(__self_0))
                        }
                        Scalar::Int(__self_0) => {
                            Scalar::Int(::core::clone::Clone::clone(__self_0))
                        }
                        Scalar::Float(__self_0) => {
                            Scalar::Float(::core::clone::Clone::clone(__self_0))
                        }
                        Scalar::Boolean(__self_0) => {
                            Scalar::Boolean(::core::clone::Clone::clone(__self_0))
                        }
                        Scalar::Bytes(__self_0) => {
                            Scalar::Bytes(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            impl ::core::fmt::Debug for Scalar {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Scalar::Str(e) => f.debug_tuple("Scalar::Str").field(e).finish(),
                        Scalar::Int(e) => f.debug_tuple("Scalar::Int").field(e).finish(),
                        Scalar::Float(e) => {
                            f.debug_tuple("Scalar::Float").field(e).finish()
                        }
                        Scalar::Boolean(e) => {
                            f.debug_tuple("Scalar::Boolean").field(e).finish()
                        }
                        Scalar::Bytes(e) => {
                            f.debug_tuple("Scalar::Bytes").field(e).finish()
                        }
                    }
                }
            }
            #[repr(transparent)]
            pub struct Logview {
                handle: _rt::Resource<Logview>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Logview {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Logview",
                        "handle",
                        &&self.handle,
                    )
                }
            }
            impl Logview {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for Logview {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    unsafe extern "C" fn drop(_: i32) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    unsafe {
                        drop(_handle as i32);
                    }
                }
            }
            impl Logview {
                #[allow(unused_unsafe, clippy::all)]
                /// JSONPath/dot-path style, e.g. "detail.findings[0].CompanyName"
                #[allow(async_fn_in_trait)]
                pub fn has(&self, path: &str) -> bool {
                    unsafe {
                        let vec0 = path;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        unsafe extern "C" fn wit_import1(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                        ) -> i32 {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        let ret = wit_import1(
                            (self).handle() as i32,
                            ptr0.cast_mut(),
                            len0,
                        );
                        _rt::bool_lift(ret as u8)
                    }
                }
            }
            impl Logview {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn get(&self, path: &str) -> Option<Scalar> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 16 + 2 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16
                                + 2 * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = path;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result15 = match l3 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr1.add(8).cast::<u8>());
                                    let v14 = match l4 {
                                        0 => {
                                            let e14 = {
                                                let l5 = *ptr1.add(16).cast::<*mut u8>();
                                                let l6 = *ptr1
                                                    .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len7 = l6;
                                                let bytes7 = _rt::Vec::from_raw_parts(
                                                    l5.cast(),
                                                    len7,
                                                    len7,
                                                );
                                                _rt::string_lift(bytes7)
                                            };
                                            Scalar::Str(e14)
                                        }
                                        1 => {
                                            let e14 = {
                                                let l8 = *ptr1.add(16).cast::<i64>();
                                                l8
                                            };
                                            Scalar::Int(e14)
                                        }
                                        2 => {
                                            let e14 = {
                                                let l9 = *ptr1.add(16).cast::<f64>();
                                                l9
                                            };
                                            Scalar::Float(e14)
                                        }
                                        3 => {
                                            let e14 = {
                                                let l10 = i32::from(*ptr1.add(16).cast::<u8>());
                                                _rt::bool_lift(l10 as u8)
                                            };
                                            Scalar::Boolean(e14)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &4) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            let e14 = {
                                                let l11 = *ptr1.add(16).cast::<*mut u8>();
                                                let l12 = *ptr1
                                                    .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len13 = l12;
                                                _rt::Vec::from_raw_parts(l11.cast(), len13, len13)
                                            };
                                            Scalar::Bytes(e14)
                                        }
                                    };
                                    v14
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result15
                    }
                }
            }
            impl Logview {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn len(&self, path: &str) -> Option<u32> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let vec0 = path;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result5 = match l3 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l4 = *ptr1.add(4).cast::<i32>();
                                    l4 as u32
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl Logview {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn get_list(&self, path: &str) -> Option<_rt::Vec<Scalar>> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = path;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result18 = match l3 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l4 = *ptr1
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l5 = *ptr1
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base17 = l4;
                                    let len17 = l5;
                                    let mut result17 = _rt::Vec::with_capacity(len17);
                                    for i in 0..len17 {
                                        let base = base17
                                            .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                        let e17 = {
                                            let l6 = i32::from(*base.add(0).cast::<u8>());
                                            let v16 = match l6 {
                                                0 => {
                                                    let e16 = {
                                                        let l7 = *base.add(8).cast::<*mut u8>();
                                                        let l8 = *base
                                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len9 = l8;
                                                        let bytes9 = _rt::Vec::from_raw_parts(
                                                            l7.cast(),
                                                            len9,
                                                            len9,
                                                        );
                                                        _rt::string_lift(bytes9)
                                                    };
                                                    Scalar::Str(e16)
                                                }
                                                1 => {
                                                    let e16 = {
                                                        let l10 = *base.add(8).cast::<i64>();
                                                        l10
                                                    };
                                                    Scalar::Int(e16)
                                                }
                                                2 => {
                                                    let e16 = {
                                                        let l11 = *base.add(8).cast::<f64>();
                                                        l11
                                                    };
                                                    Scalar::Float(e16)
                                                }
                                                3 => {
                                                    let e16 = {
                                                        let l12 = i32::from(*base.add(8).cast::<u8>());
                                                        _rt::bool_lift(l12 as u8)
                                                    };
                                                    Scalar::Boolean(e16)
                                                }
                                                n => {
                                                    if true {
                                                        match (&n, &4) {
                                                            (left_val, right_val) => {
                                                                if !(*left_val == *right_val) {
                                                                    let kind = ::core::panicking::AssertKind::Eq;
                                                                    ::core::panicking::assert_failed(
                                                                        kind,
                                                                        &*left_val,
                                                                        &*right_val,
                                                                        ::core::option::Option::Some(
                                                                            format_args!("invalid enum discriminant"),
                                                                        ),
                                                                    );
                                                                }
                                                            }
                                                        };
                                                    }
                                                    let e16 = {
                                                        let l13 = *base.add(8).cast::<*mut u8>();
                                                        let l14 = *base
                                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len15 = l14;
                                                        _rt::Vec::from_raw_parts(l13.cast(), len15, len15)
                                                    };
                                                    Scalar::Bytes(e16)
                                                }
                                            };
                                            v16
                                        };
                                        result17.push(e17);
                                    }
                                    _rt::cabi_dealloc(
                                        base17,
                                        len17 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                        8,
                                    );
                                    result17
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result18
                    }
                }
            }
            impl Logview {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn get_map(
                    &self,
                    path: &str,
                ) -> Option<_rt::Vec<(_rt::String, Scalar)>> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = path;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result21 = match l3 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l4 = *ptr1
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l5 = *ptr1
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base20 = l4;
                                    let len20 = l5;
                                    let mut result20 = _rt::Vec::with_capacity(len20);
                                    for i in 0..len20 {
                                        let base = base20
                                            .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                        let e20 = {
                                            let l6 = *base.add(0).cast::<*mut u8>();
                                            let l7 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len8 = l7;
                                            let bytes8 = _rt::Vec::from_raw_parts(
                                                l6.cast(),
                                                len8,
                                                len8,
                                            );
                                            let l9 = i32::from(
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            let v19 = match l9 {
                                                0 => {
                                                    let e19 = {
                                                        let l10 = *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l11 = *base
                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len12 = l11;
                                                        let bytes12 = _rt::Vec::from_raw_parts(
                                                            l10.cast(),
                                                            len12,
                                                            len12,
                                                        );
                                                        _rt::string_lift(bytes12)
                                                    };
                                                    Scalar::Str(e19)
                                                }
                                                1 => {
                                                    let e19 = {
                                                        let l13 = *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>();
                                                        l13
                                                    };
                                                    Scalar::Int(e19)
                                                }
                                                2 => {
                                                    let e19 = {
                                                        let l14 = *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<f64>();
                                                        l14
                                                    };
                                                    Scalar::Float(e19)
                                                }
                                                3 => {
                                                    let e19 = {
                                                        let l15 = i32::from(
                                                            *base
                                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u8>(),
                                                        );
                                                        _rt::bool_lift(l15 as u8)
                                                    };
                                                    Scalar::Boolean(e19)
                                                }
                                                n => {
                                                    if true {
                                                        match (&n, &4) {
                                                            (left_val, right_val) => {
                                                                if !(*left_val == *right_val) {
                                                                    let kind = ::core::panicking::AssertKind::Eq;
                                                                    ::core::panicking::assert_failed(
                                                                        kind,
                                                                        &*left_val,
                                                                        &*right_val,
                                                                        ::core::option::Option::Some(
                                                                            format_args!("invalid enum discriminant"),
                                                                        ),
                                                                    );
                                                                }
                                                            }
                                                        };
                                                    }
                                                    let e19 = {
                                                        let l16 = *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l17 = *base
                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len18 = l17;
                                                        _rt::Vec::from_raw_parts(l16.cast(), len18, len18)
                                                    };
                                                    Scalar::Bytes(e19)
                                                }
                                            };
                                            (_rt::string_lift(bytes8), v19)
                                        };
                                        result20.push(e20);
                                    }
                                    _rt::cabi_dealloc(
                                        base20,
                                        len20 * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                        8,
                                    );
                                    result20
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result21
                    }
                }
            }
            impl Logview {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn keys(&self, path: &str) -> _rt::Vec<_rt::String> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 2 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = path;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
                        let l3 = *ptr1.add(0).cast::<*mut u8>();
                        let l4 = *ptr1
                            .add(::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let base8 = l3;
                        let len8 = l4;
                        let mut result8 = _rt::Vec::with_capacity(len8);
                        for i in 0..len8 {
                            let base = base8
                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                            let e8 = {
                                let l5 = *base.add(0).cast::<*mut u8>();
                                let l6 = *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len7 = l6;
                                let bytes7 = _rt::Vec::from_raw_parts(
                                    l5.cast(),
                                    len7,
                                    len7,
                                );
                                _rt::string_lift(bytes7)
                            };
                            result8.push(e8);
                        }
                        _rt::cabi_dealloc(
                            base8,
                            len8 * (2 * ::core::mem::size_of::<*const u8>()),
                            ::core::mem::size_of::<*const u8>(),
                        );
                        let result9 = result8;
                        result9
                    }
                }
            }
        }
    }
}
#[allow(dead_code, clippy::all)]
pub mod wasi {
    pub mod cli {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod environment {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[allow(unused_unsafe, clippy::all)]
            /// Get the POSIX-style environment variables.
            ///
            /// Each environment variable is provided as a pair of string variable names
            /// and string value.
            ///
            /// Morally, these are a value import, but until value imports are available
            /// in the component model, this import function should return the same
            /// values each time it is called.
            #[allow(async_fn_in_trait)]
            pub fn get_environment() -> _rt::Vec<(_rt::String, _rt::String)> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import1(ptr0);
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base10 = l2;
                    let len10 = l3;
                    let mut result10 = _rt::Vec::with_capacity(len10);
                    for i in 0..len10 {
                        let base = base10
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        let e10 = {
                            let l4 = *base.add(0).cast::<*mut u8>();
                            let l5 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len6 = l5;
                            let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                            let l7 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l8 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len9 = l8;
                            let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                            (_rt::string_lift(bytes6), _rt::string_lift(bytes9))
                        };
                        result10.push(e10);
                    }
                    _rt::cabi_dealloc(
                        base10,
                        len10 * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result11 = result10;
                    result11
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get the POSIX-style arguments to the program.
            #[allow(async_fn_in_trait)]
            pub fn get_arguments() -> _rt::Vec<_rt::String> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import1(ptr0);
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base7 = l2;
                    let len7 = l3;
                    let mut result7 = _rt::Vec::with_capacity(len7);
                    for i in 0..len7 {
                        let base = base7
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        let e7 = {
                            let l4 = *base.add(0).cast::<*mut u8>();
                            let l5 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len6 = l5;
                            let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                            _rt::string_lift(bytes6)
                        };
                        result7.push(e7);
                    }
                    _rt::cabi_dealloc(
                        base7,
                        len7 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result8 = result7;
                    result8
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Return a path that programs should use as their initial current working
            /// directory, interpreting `.` as shorthand for this.
            #[allow(async_fn_in_trait)]
            pub fn initial_cwd() -> Option<_rt::String> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 3 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 3
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import1(ptr0);
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result6 = match l2 {
                        0 => None,
                        1 => {
                            let e = {
                                let l3 = *ptr0
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l4 = *ptr0
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len5 = l4;
                                let bytes5 = _rt::Vec::from_raw_parts(
                                    l3.cast(),
                                    len5,
                                    len5,
                                );
                                _rt::string_lift(bytes5)
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result6
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod exit {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            #[allow(unused_unsafe, clippy::all)]
            /// Exit the current instance and any linked instances.
            #[allow(async_fn_in_trait)]
            pub fn exit(status: Result<(), ()>) -> () {
                unsafe {
                    let result0 = match status {
                        Ok(_) => 0i32,
                        Err(_) => 1i32,
                    };
                    unsafe extern "C" fn wit_import1(_: i32) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import1(result0);
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod stdin {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            pub type InputStream = super::super::super::wasi::io::streams::InputStream;
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn get_stdin() -> InputStream {
                unsafe {
                    unsafe extern "C" fn wit_import0() -> i32 {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    let ret = wit_import0();
                    super::super::super::wasi::io::streams::InputStream::from_handle(
                        ret as u32,
                    )
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod stdout {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn get_stdout() -> OutputStream {
                unsafe {
                    unsafe extern "C" fn wit_import0() -> i32 {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    let ret = wit_import0();
                    super::super::super::wasi::io::streams::OutputStream::from_handle(
                        ret as u32,
                    )
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod stderr {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn get_stderr() -> OutputStream {
                unsafe {
                    unsafe extern "C" fn wit_import0() -> i32 {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    let ret = wit_import0();
                    super::super::super::wasi::io::streams::OutputStream::from_handle(
                        ret as u32,
                    )
                }
            }
        }
        /// Terminal input.
        ///
        /// In the future, this may include functions for disabling echoing,
        /// disabling input buffering so that keyboard events are sent through
        /// immediately, querying supported features, and so on.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod terminal_input {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            /// The input side of a terminal.
            #[repr(transparent)]
            pub struct TerminalInput {
                handle: _rt::Resource<TerminalInput>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for TerminalInput {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "TerminalInput",
                        "handle",
                        &&self.handle,
                    )
                }
            }
            impl TerminalInput {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for TerminalInput {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    unsafe extern "C" fn drop(_: i32) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    unsafe {
                        drop(_handle as i32);
                    }
                }
            }
        }
        /// Terminal output.
        ///
        /// In the future, this may include functions for querying the terminal
        /// size, being notified of terminal size changes, querying supported
        /// features, and so on.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod terminal_output {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            /// The output side of a terminal.
            #[repr(transparent)]
            pub struct TerminalOutput {
                handle: _rt::Resource<TerminalOutput>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for TerminalOutput {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "TerminalOutput",
                        "handle",
                        &&self.handle,
                    )
                }
            }
            impl TerminalOutput {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for TerminalOutput {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    unsafe extern "C" fn drop(_: i32) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    unsafe {
                        drop(_handle as i32);
                    }
                }
            }
        }
        /// An interface providing an optional `terminal-input` for stdin as a
        /// link-time authority.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod terminal_stdin {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type TerminalInput = super::super::super::wasi::cli::terminal_input::TerminalInput;
            #[allow(unused_unsafe, clippy::all)]
            /// If stdin is connected to a terminal, return a `terminal-input` handle
            /// allowing further interaction with it.
            #[allow(async_fn_in_trait)]
            pub fn get_terminal_stdin() -> Option<TerminalInput> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import1(ptr0);
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result4 = match l2 {
                        0 => None,
                        1 => {
                            let e = {
                                let l3 = *ptr0.add(4).cast::<i32>();
                                super::super::super::wasi::cli::terminal_input::TerminalInput::from_handle(
                                    l3 as u32,
                                )
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result4
                }
            }
        }
        /// An interface providing an optional `terminal-output` for stdout as a
        /// link-time authority.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod terminal_stdout {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type TerminalOutput = super::super::super::wasi::cli::terminal_output::TerminalOutput;
            #[allow(unused_unsafe, clippy::all)]
            /// If stdout is connected to a terminal, return a `terminal-output` handle
            /// allowing further interaction with it.
            #[allow(async_fn_in_trait)]
            pub fn get_terminal_stdout() -> Option<TerminalOutput> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import1(ptr0);
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result4 = match l2 {
                        0 => None,
                        1 => {
                            let e = {
                                let l3 = *ptr0.add(4).cast::<i32>();
                                super::super::super::wasi::cli::terminal_output::TerminalOutput::from_handle(
                                    l3 as u32,
                                )
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result4
                }
            }
        }
        /// An interface providing an optional `terminal-output` for stderr as a
        /// link-time authority.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod terminal_stderr {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type TerminalOutput = super::super::super::wasi::cli::terminal_output::TerminalOutput;
            #[allow(unused_unsafe, clippy::all)]
            /// If stderr is connected to a terminal, return a `terminal-output` handle
            /// allowing further interaction with it.
            #[allow(async_fn_in_trait)]
            pub fn get_terminal_stderr() -> Option<TerminalOutput> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import1(ptr0);
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result4 = match l2 {
                        0 => None,
                        1 => {
                            let e = {
                                let l3 = *ptr0.add(4).cast::<i32>();
                                super::super::super::wasi::cli::terminal_output::TerminalOutput::from_handle(
                                    l3 as u32,
                                )
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result4
                }
            }
        }
    }
    pub mod clocks {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod monotonic_clock {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Pollable = super::super::super::wasi::io::poll::Pollable;
            pub type Instant = u64;
            pub type Duration = u64;
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn now() -> Instant {
                unsafe {
                    unsafe extern "C" fn wit_import0() -> i64 {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    let ret = wit_import0();
                    ret as u64
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn resolution() -> Duration {
                unsafe {
                    unsafe extern "C" fn wit_import0() -> i64 {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    let ret = wit_import0();
                    ret as u64
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn subscribe_instant(when: Instant) -> Pollable {
                unsafe {
                    unsafe extern "C" fn wit_import0(_: i64) -> i32 {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    let ret = wit_import0(_rt::as_i64(when));
                    super::super::super::wasi::io::poll::Pollable::from_handle(
                        ret as u32,
                    )
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn subscribe_duration(when: Duration) -> Pollable {
                unsafe {
                    unsafe extern "C" fn wit_import0(_: i64) -> i32 {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    let ret = wit_import0(_rt::as_i64(when));
                    super::super::super::wasi::io::poll::Pollable::from_handle(
                        ret as u32,
                    )
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod wall_clock {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            #[repr(C)]
            pub struct Datetime {
                pub seconds: u64,
                pub nanoseconds: u32,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Datetime {
                #[inline]
                fn clone(&self) -> Datetime {
                    let _: ::core::clone::AssertParamIsClone<u64>;
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Datetime {}
            impl ::core::fmt::Debug for Datetime {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Datetime")
                        .field("seconds", &self.seconds)
                        .field("nanoseconds", &self.nanoseconds)
                        .finish()
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn now() -> Datetime {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import1(ptr0);
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i32>();
                    let result4 = Datetime {
                        seconds: l2 as u64,
                        nanoseconds: l3 as u32,
                    };
                    result4
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn resolution() -> Datetime {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import1(ptr0);
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i32>();
                    let result4 = Datetime {
                        seconds: l2 as u64,
                        nanoseconds: l3 as u32,
                    };
                    result4
                }
            }
        }
    }
    pub mod filesystem {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type InputStream = super::super::super::wasi::io::streams::InputStream;
            pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
            pub type Error = super::super::super::wasi::io::streams::Error;
            pub type Datetime = super::super::super::wasi::clocks::wall_clock::Datetime;
            pub type Filesize = u64;
            #[repr(u8)]
            pub enum DescriptorType {
                Unknown,
                BlockDevice,
                CharacterDevice,
                Directory,
                Fifo,
                SymbolicLink,
                RegularFile,
                Socket,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for DescriptorType {
                #[inline]
                fn clone(&self) -> DescriptorType {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for DescriptorType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for DescriptorType {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for DescriptorType {
                #[inline]
                fn cmp(&self, other: &DescriptorType) -> ::core::cmp::Ordering {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for DescriptorType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for DescriptorType {
                #[inline]
                fn eq(&self, other: &DescriptorType) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for DescriptorType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &DescriptorType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
                }
            }
            impl ::core::fmt::Debug for DescriptorType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        DescriptorType::Unknown => {
                            f.debug_tuple("DescriptorType::Unknown").finish()
                        }
                        DescriptorType::BlockDevice => {
                            f.debug_tuple("DescriptorType::BlockDevice").finish()
                        }
                        DescriptorType::CharacterDevice => {
                            f.debug_tuple("DescriptorType::CharacterDevice").finish()
                        }
                        DescriptorType::Directory => {
                            f.debug_tuple("DescriptorType::Directory").finish()
                        }
                        DescriptorType::Fifo => {
                            f.debug_tuple("DescriptorType::Fifo").finish()
                        }
                        DescriptorType::SymbolicLink => {
                            f.debug_tuple("DescriptorType::SymbolicLink").finish()
                        }
                        DescriptorType::RegularFile => {
                            f.debug_tuple("DescriptorType::RegularFile").finish()
                        }
                        DescriptorType::Socket => {
                            f.debug_tuple("DescriptorType::Socket").finish()
                        }
                    }
                }
            }
            impl DescriptorType {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> DescriptorType {
                    if !true {
                        return unsafe { ::core::mem::transmute(val) };
                    }
                    match val {
                        0 => DescriptorType::Unknown,
                        1 => DescriptorType::BlockDevice,
                        2 => DescriptorType::CharacterDevice,
                        3 => DescriptorType::Directory,
                        4 => DescriptorType::Fifo,
                        5 => DescriptorType::SymbolicLink,
                        6 => DescriptorType::RegularFile,
                        7 => DescriptorType::Socket,
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("invalid enum discriminant"),
                            );
                        }
                    }
                }
            }
            pub struct DescriptorFlags(
                <DescriptorFlags as ::bitflags::__private::PublicFlags>::Internal,
            );
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for DescriptorFlags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for DescriptorFlags {
                #[inline]
                fn eq(&self, other: &DescriptorFlags) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for DescriptorFlags {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        <DescriptorFlags as ::bitflags::__private::PublicFlags>::Internal,
                    >;
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for DescriptorFlags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &DescriptorFlags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for DescriptorFlags {
                #[inline]
                fn cmp(&self, other: &DescriptorFlags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for DescriptorFlags {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for DescriptorFlags {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "DescriptorFlags",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for DescriptorFlags {
                #[inline]
                fn clone(&self) -> DescriptorFlags {
                    let _: ::core::clone::AssertParamIsClone<
                        <DescriptorFlags as ::bitflags::__private::PublicFlags>::Internal,
                    >;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for DescriptorFlags {}
            impl DescriptorFlags {
                #[allow(deprecated, non_upper_case_globals)]
                pub const READ: Self = Self::from_bits_retain(1 << 0);
                #[allow(deprecated, non_upper_case_globals)]
                pub const WRITE: Self = Self::from_bits_retain(1 << 1);
                #[allow(deprecated, non_upper_case_globals)]
                pub const FILE_INTEGRITY_SYNC: Self = Self::from_bits_retain(1 << 2);
                #[allow(deprecated, non_upper_case_globals)]
                pub const DATA_INTEGRITY_SYNC: Self = Self::from_bits_retain(1 << 3);
                #[allow(deprecated, non_upper_case_globals)]
                pub const REQUESTED_WRITE_SYNC: Self = Self::from_bits_retain(1 << 4);
                #[allow(deprecated, non_upper_case_globals)]
                pub const MUTATE_DIRECTORY: Self = Self::from_bits_retain(1 << 5);
            }
            impl ::bitflags::Flags for DescriptorFlags {
                const FLAGS: &'static [::bitflags::Flag<DescriptorFlags>] = &[
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new("READ", DescriptorFlags::READ)
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new("WRITE", DescriptorFlags::WRITE)
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new(
                            "FILE_INTEGRITY_SYNC",
                            DescriptorFlags::FILE_INTEGRITY_SYNC,
                        )
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new(
                            "DATA_INTEGRITY_SYNC",
                            DescriptorFlags::DATA_INTEGRITY_SYNC,
                        )
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new(
                            "REQUESTED_WRITE_SYNC",
                            DescriptorFlags::REQUESTED_WRITE_SYNC,
                        )
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new(
                            "MUTATE_DIRECTORY",
                            DescriptorFlags::MUTATE_DIRECTORY,
                        )
                    },
                ];
                type Bits = u8;
                fn bits(&self) -> u8 {
                    DescriptorFlags::bits(self)
                }
                fn from_bits_retain(bits: u8) -> DescriptorFlags {
                    DescriptorFlags::from_bits_retain(bits)
                }
            }
            #[allow(
                dead_code,
                deprecated,
                unused_doc_comments,
                unused_attributes,
                unused_mut,
                unused_imports,
                non_upper_case_globals,
                clippy::assign_op_pattern,
                clippy::indexing_slicing,
                clippy::same_name_method,
                clippy::iter_without_into_iter,
            )]
            const _: () = {
                #[repr(transparent)]
                pub struct InternalBitFlags(u8);
                #[automatically_derived]
                impl ::core::clone::Clone for InternalBitFlags {
                    #[inline]
                    fn clone(&self) -> InternalBitFlags {
                        let _: ::core::clone::AssertParamIsClone<u8>;
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for InternalBitFlags {}
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for InternalBitFlags {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for InternalBitFlags {
                    #[inline]
                    fn eq(&self, other: &InternalBitFlags) -> bool {
                        self.0 == other.0
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::Eq for InternalBitFlags {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {
                        let _: ::core::cmp::AssertParamIsEq<u8>;
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::PartialOrd for InternalBitFlags {
                    #[inline]
                    fn partial_cmp(
                        &self,
                        other: &InternalBitFlags,
                    ) -> ::core::option::Option<::core::cmp::Ordering> {
                        ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::Ord for InternalBitFlags {
                    #[inline]
                    fn cmp(&self, other: &InternalBitFlags) -> ::core::cmp::Ordering {
                        ::core::cmp::Ord::cmp(&self.0, &other.0)
                    }
                }
                #[automatically_derived]
                impl ::core::hash::Hash for InternalBitFlags {
                    #[inline]
                    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                        ::core::hash::Hash::hash(&self.0, state)
                    }
                }
                impl ::bitflags::__private::PublicFlags for DescriptorFlags {
                    type Primitive = u8;
                    type Internal = InternalBitFlags;
                }
                impl ::bitflags::__private::core::default::Default for InternalBitFlags {
                    #[inline]
                    fn default() -> Self {
                        InternalBitFlags::empty()
                    }
                }
                impl ::bitflags::__private::core::fmt::Debug for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        if self.is_empty() {
                            f.write_fmt(
                                format_args!("{0:#x}", <u8 as ::bitflags::Bits>::EMPTY),
                            )
                        } else {
                            ::bitflags::__private::core::fmt::Display::fmt(self, f)
                        }
                    }
                }
                impl ::bitflags::__private::core::fmt::Display for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::parser::to_writer(&DescriptorFlags(*self), f)
                    }
                }
                impl ::bitflags::__private::core::str::FromStr for InternalBitFlags {
                    type Err = ::bitflags::parser::ParseError;
                    fn from_str(
                        s: &str,
                    ) -> ::bitflags::__private::core::result::Result<Self, Self::Err> {
                        ::bitflags::parser::from_str::<DescriptorFlags>(s)
                            .map(|flags| flags.0)
                    }
                }
                impl ::bitflags::__private::core::convert::AsRef<u8>
                for InternalBitFlags {
                    fn as_ref(&self) -> &u8 {
                        &self.0
                    }
                }
                impl ::bitflags::__private::core::convert::From<u8>
                for InternalBitFlags {
                    fn from(bits: u8) -> Self {
                        Self::from_bits_retain(bits)
                    }
                }
                #[allow(dead_code, deprecated, unused_attributes)]
                impl InternalBitFlags {
                    /// Get a flags value with all bits unset.
                    #[inline]
                    pub const fn empty() -> Self {
                        Self(<u8 as ::bitflags::Bits>::EMPTY)
                    }
                    /// Get a flags value with all known bits set.
                    #[inline]
                    pub const fn all() -> Self {
                        let mut truncated = <u8 as ::bitflags::Bits>::EMPTY;
                        let mut i = 0;
                        {
                            {
                                let flag = <DescriptorFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        {
                            {
                                let flag = <DescriptorFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        {
                            {
                                let flag = <DescriptorFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        {
                            {
                                let flag = <DescriptorFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        {
                            {
                                let flag = <DescriptorFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        {
                            {
                                let flag = <DescriptorFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        let _ = i;
                        Self(truncated)
                    }
                    /// Get the underlying bits value.
                    ///
                    /// The returned value is exactly the bits set in this flags value.
                    #[inline]
                    pub const fn bits(&self) -> u8 {
                        self.0
                    }
                    /// Convert from a bits value.
                    ///
                    /// This method will return `None` if any unknown bits are set.
                    #[inline]
                    pub const fn from_bits(
                        bits: u8,
                    ) -> ::bitflags::__private::core::option::Option<Self> {
                        let truncated = Self::from_bits_truncate(bits).0;
                        if truncated == bits {
                            ::bitflags::__private::core::option::Option::Some(Self(bits))
                        } else {
                            ::bitflags::__private::core::option::Option::None
                        }
                    }
                    /// Convert from a bits value, unsetting any unknown bits.
                    #[inline]
                    pub const fn from_bits_truncate(bits: u8) -> Self {
                        Self(bits & Self::all().0)
                    }
                    /// Convert from a bits value exactly.
                    #[inline]
                    pub const fn from_bits_retain(bits: u8) -> Self {
                        Self(bits)
                    }
                    /// Get a flags value with the bits of a flag with the given name set.
                    ///
                    /// This method will return `None` if `name` is empty or doesn't
                    /// correspond to any named flag.
                    #[inline]
                    pub fn from_name(
                        name: &str,
                    ) -> ::bitflags::__private::core::option::Option<Self> {
                        {
                            if name == "READ" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(DescriptorFlags::READ.bits()),
                                );
                            }
                        };
                        {
                            if name == "WRITE" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(DescriptorFlags::WRITE.bits()),
                                );
                            }
                        };
                        {
                            if name == "FILE_INTEGRITY_SYNC" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(DescriptorFlags::FILE_INTEGRITY_SYNC.bits()),
                                );
                            }
                        };
                        {
                            if name == "DATA_INTEGRITY_SYNC" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(DescriptorFlags::DATA_INTEGRITY_SYNC.bits()),
                                );
                            }
                        };
                        {
                            if name == "REQUESTED_WRITE_SYNC" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(DescriptorFlags::REQUESTED_WRITE_SYNC.bits()),
                                );
                            }
                        };
                        {
                            if name == "MUTATE_DIRECTORY" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(DescriptorFlags::MUTATE_DIRECTORY.bits()),
                                );
                            }
                        };
                        let _ = name;
                        ::bitflags::__private::core::option::Option::None
                    }
                    /// Whether all bits in this flags value are unset.
                    #[inline]
                    pub const fn is_empty(&self) -> bool {
                        self.0 == <u8 as ::bitflags::Bits>::EMPTY
                    }
                    /// Whether all known bits in this flags value are set.
                    #[inline]
                    pub const fn is_all(&self) -> bool {
                        Self::all().0 | self.0 == self.0
                    }
                    /// Whether any set bits in a source flags value are also set in a target flags value.
                    #[inline]
                    pub const fn intersects(&self, other: Self) -> bool {
                        self.0 & other.0 != <u8 as ::bitflags::Bits>::EMPTY
                    }
                    /// Whether all set bits in a source flags value are also set in a target flags value.
                    #[inline]
                    pub const fn contains(&self, other: Self) -> bool {
                        self.0 & other.0 == other.0
                    }
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    pub fn insert(&mut self, other: Self) {
                        *self = Self(self.0).union(other);
                    }
                    /// The intersection of a source flags value with the complement of a target flags
                    /// value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `remove` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    pub fn remove(&mut self, other: Self) {
                        *self = Self(self.0).difference(other);
                    }
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    pub fn toggle(&mut self, other: Self) {
                        *self = Self(self.0).symmetric_difference(other);
                    }
                    /// Call `insert` when `value` is `true` or `remove` when `value` is `false`.
                    #[inline]
                    pub fn set(&mut self, other: Self, value: bool) {
                        if value {
                            self.insert(other);
                        } else {
                            self.remove(other);
                        }
                    }
                    /// The bitwise and (`&`) of the bits in two flags values.
                    #[inline]
                    #[must_use]
                    pub const fn intersection(self, other: Self) -> Self {
                        Self(self.0 & other.0)
                    }
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    #[must_use]
                    pub const fn union(self, other: Self) -> Self {
                        Self(self.0 | other.0)
                    }
                    /// The intersection of a source flags value with the complement of a target flags
                    /// value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `difference` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    #[must_use]
                    pub const fn difference(self, other: Self) -> Self {
                        Self(self.0 & !other.0)
                    }
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    #[must_use]
                    pub const fn symmetric_difference(self, other: Self) -> Self {
                        Self(self.0 ^ other.0)
                    }
                    /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                    #[inline]
                    #[must_use]
                    pub const fn complement(self) -> Self {
                        Self::from_bits_truncate(!self.0)
                    }
                }
                impl ::bitflags::__private::core::fmt::Binary for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::Binary::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::Octal for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::Octal::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::LowerHex for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::LowerHex::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::UpperHex for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::UpperHex::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::ops::BitOr for InternalBitFlags {
                    type Output = Self;
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    fn bitor(self, other: InternalBitFlags) -> Self {
                        self.union(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitOrAssign for InternalBitFlags {
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    fn bitor_assign(&mut self, other: Self) {
                        self.insert(other);
                    }
                }
                impl ::bitflags::__private::core::ops::BitXor for InternalBitFlags {
                    type Output = Self;
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    fn bitxor(self, other: Self) -> Self {
                        self.symmetric_difference(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitXorAssign
                for InternalBitFlags {
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    fn bitxor_assign(&mut self, other: Self) {
                        self.toggle(other);
                    }
                }
                impl ::bitflags::__private::core::ops::BitAnd for InternalBitFlags {
                    type Output = Self;
                    /// The bitwise and (`&`) of the bits in two flags values.
                    #[inline]
                    fn bitand(self, other: Self) -> Self {
                        self.intersection(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitAndAssign
                for InternalBitFlags {
                    /// The bitwise and (`&`) of the bits in two flags values.
                    #[inline]
                    fn bitand_assign(&mut self, other: Self) {
                        *self = Self::from_bits_retain(self.bits()).intersection(other);
                    }
                }
                impl ::bitflags::__private::core::ops::Sub for InternalBitFlags {
                    type Output = Self;
                    /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `difference` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    fn sub(self, other: Self) -> Self {
                        self.difference(other)
                    }
                }
                impl ::bitflags::__private::core::ops::SubAssign for InternalBitFlags {
                    /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `difference` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    fn sub_assign(&mut self, other: Self) {
                        self.remove(other);
                    }
                }
                impl ::bitflags::__private::core::ops::Not for InternalBitFlags {
                    type Output = Self;
                    /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                    #[inline]
                    fn not(self) -> Self {
                        self.complement()
                    }
                }
                impl ::bitflags::__private::core::iter::Extend<InternalBitFlags>
                for InternalBitFlags {
                    /// The bitwise or (`|`) of the bits in each flags value.
                    fn extend<
                        T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                    >(&mut self, iterator: T) {
                        for item in iterator {
                            self.insert(item)
                        }
                    }
                }
                impl ::bitflags::__private::core::iter::FromIterator<InternalBitFlags>
                for InternalBitFlags {
                    /// The bitwise or (`|`) of the bits in each flags value.
                    fn from_iter<
                        T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                    >(iterator: T) -> Self {
                        use ::bitflags::__private::core::iter::Extend;
                        let mut result = Self::empty();
                        result.extend(iterator);
                        result
                    }
                }
                impl InternalBitFlags {
                    /// Yield a set of contained flags values.
                    ///
                    /// Each yielded flags value will correspond to a defined named flag. Any unknown bits
                    /// will be yielded together as a final flags value.
                    #[inline]
                    pub const fn iter(&self) -> ::bitflags::iter::Iter<DescriptorFlags> {
                        ::bitflags::iter::Iter::__private_const_new(
                            <DescriptorFlags as ::bitflags::Flags>::FLAGS,
                            DescriptorFlags::from_bits_retain(self.bits()),
                            DescriptorFlags::from_bits_retain(self.bits()),
                        )
                    }
                    /// Yield a set of contained named flags values.
                    ///
                    /// This method is like [`iter`](#method.iter), except only yields bits in contained named flags.
                    /// Any unknown bits, or bits not corresponding to a contained flag will not be yielded.
                    #[inline]
                    pub const fn iter_names(
                        &self,
                    ) -> ::bitflags::iter::IterNames<DescriptorFlags> {
                        ::bitflags::iter::IterNames::__private_const_new(
                            <DescriptorFlags as ::bitflags::Flags>::FLAGS,
                            DescriptorFlags::from_bits_retain(self.bits()),
                            DescriptorFlags::from_bits_retain(self.bits()),
                        )
                    }
                }
                impl ::bitflags::__private::core::iter::IntoIterator
                for InternalBitFlags {
                    type Item = DescriptorFlags;
                    type IntoIter = ::bitflags::iter::Iter<DescriptorFlags>;
                    fn into_iter(self) -> Self::IntoIter {
                        self.iter()
                    }
                }
                impl InternalBitFlags {
                    /// Returns a mutable reference to the raw value of the flags currently stored.
                    #[inline]
                    pub fn bits_mut(&mut self) -> &mut u8 {
                        &mut self.0
                    }
                }
                #[allow(dead_code, deprecated, unused_attributes)]
                impl DescriptorFlags {
                    /// Get a flags value with all bits unset.
                    #[inline]
                    pub const fn empty() -> Self {
                        Self(InternalBitFlags::empty())
                    }
                    /// Get a flags value with all known bits set.
                    #[inline]
                    pub const fn all() -> Self {
                        Self(InternalBitFlags::all())
                    }
                    /// Get the underlying bits value.
                    ///
                    /// The returned value is exactly the bits set in this flags value.
                    #[inline]
                    pub const fn bits(&self) -> u8 {
                        self.0.bits()
                    }
                    /// Convert from a bits value.
                    ///
                    /// This method will return `None` if any unknown bits are set.
                    #[inline]
                    pub const fn from_bits(
                        bits: u8,
                    ) -> ::bitflags::__private::core::option::Option<Self> {
                        match InternalBitFlags::from_bits(bits) {
                            ::bitflags::__private::core::option::Option::Some(bits) => {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            }
                            ::bitflags::__private::core::option::Option::None => {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                    /// Convert from a bits value, unsetting any unknown bits.
                    #[inline]
                    pub const fn from_bits_truncate(bits: u8) -> Self {
                        Self(InternalBitFlags::from_bits_truncate(bits))
                    }
                    /// Convert from a bits value exactly.
                    #[inline]
                    pub const fn from_bits_retain(bits: u8) -> Self {
                        Self(InternalBitFlags::from_bits_retain(bits))
                    }
                    /// Get a flags value with the bits of a flag with the given name set.
                    ///
                    /// This method will return `None` if `name` is empty or doesn't
                    /// correspond to any named flag.
                    #[inline]
                    pub fn from_name(
                        name: &str,
                    ) -> ::bitflags::__private::core::option::Option<Self> {
                        match InternalBitFlags::from_name(name) {
                            ::bitflags::__private::core::option::Option::Some(bits) => {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            }
                            ::bitflags::__private::core::option::Option::None => {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                    /// Whether all bits in this flags value are unset.
                    #[inline]
                    pub const fn is_empty(&self) -> bool {
                        self.0.is_empty()
                    }
                    /// Whether all known bits in this flags value are set.
                    #[inline]
                    pub const fn is_all(&self) -> bool {
                        self.0.is_all()
                    }
                    /// Whether any set bits in a source flags value are also set in a target flags value.
                    #[inline]
                    pub const fn intersects(&self, other: Self) -> bool {
                        self.0.intersects(other.0)
                    }
                    /// Whether all set bits in a source flags value are also set in a target flags value.
                    #[inline]
                    pub const fn contains(&self, other: Self) -> bool {
                        self.0.contains(other.0)
                    }
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    pub fn insert(&mut self, other: Self) {
                        self.0.insert(other.0)
                    }
                    /// The intersection of a source flags value with the complement of a target flags
                    /// value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `remove` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    pub fn remove(&mut self, other: Self) {
                        self.0.remove(other.0)
                    }
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    pub fn toggle(&mut self, other: Self) {
                        self.0.toggle(other.0)
                    }
                    /// Call `insert` when `value` is `true` or `remove` when `value` is `false`.
                    #[inline]
                    pub fn set(&mut self, other: Self, value: bool) {
                        self.0.set(other.0, value)
                    }
                    /// The bitwise and (`&`) of the bits in two flags values.
                    #[inline]
                    #[must_use]
                    pub const fn intersection(self, other: Self) -> Self {
                        Self(self.0.intersection(other.0))
                    }
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    #[must_use]
                    pub const fn union(self, other: Self) -> Self {
                        Self(self.0.union(other.0))
                    }
                    /// The intersection of a source flags value with the complement of a target flags
                    /// value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `difference` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    #[must_use]
                    pub const fn difference(self, other: Self) -> Self {
                        Self(self.0.difference(other.0))
                    }
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    #[must_use]
                    pub const fn symmetric_difference(self, other: Self) -> Self {
                        Self(self.0.symmetric_difference(other.0))
                    }
                    /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                    #[inline]
                    #[must_use]
                    pub const fn complement(self) -> Self {
                        Self(self.0.complement())
                    }
                }
                impl ::bitflags::__private::core::fmt::Binary for DescriptorFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::Binary::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::Octal for DescriptorFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::Octal::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::LowerHex for DescriptorFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::LowerHex::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::UpperHex for DescriptorFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::UpperHex::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::ops::BitOr for DescriptorFlags {
                    type Output = Self;
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    fn bitor(self, other: DescriptorFlags) -> Self {
                        self.union(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitOrAssign for DescriptorFlags {
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    fn bitor_assign(&mut self, other: Self) {
                        self.insert(other);
                    }
                }
                impl ::bitflags::__private::core::ops::BitXor for DescriptorFlags {
                    type Output = Self;
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    fn bitxor(self, other: Self) -> Self {
                        self.symmetric_difference(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitXorAssign for DescriptorFlags {
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    fn bitxor_assign(&mut self, other: Self) {
                        self.toggle(other);
                    }
                }
                impl ::bitflags::__private::core::ops::BitAnd for DescriptorFlags {
                    type Output = Self;
                    /// The bitwise and (`&`) of the bits in two flags values.
                    #[inline]
                    fn bitand(self, other: Self) -> Self {
                        self.intersection(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitAndAssign for DescriptorFlags {
                    /// The bitwise and (`&`) of the bits in two flags values.
                    #[inline]
                    fn bitand_assign(&mut self, other: Self) {
                        *self = Self::from_bits_retain(self.bits()).intersection(other);
                    }
                }
                impl ::bitflags::__private::core::ops::Sub for DescriptorFlags {
                    type Output = Self;
                    /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `difference` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    fn sub(self, other: Self) -> Self {
                        self.difference(other)
                    }
                }
                impl ::bitflags::__private::core::ops::SubAssign for DescriptorFlags {
                    /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `difference` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    fn sub_assign(&mut self, other: Self) {
                        self.remove(other);
                    }
                }
                impl ::bitflags::__private::core::ops::Not for DescriptorFlags {
                    type Output = Self;
                    /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                    #[inline]
                    fn not(self) -> Self {
                        self.complement()
                    }
                }
                impl ::bitflags::__private::core::iter::Extend<DescriptorFlags>
                for DescriptorFlags {
                    /// The bitwise or (`|`) of the bits in each flags value.
                    fn extend<
                        T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                    >(&mut self, iterator: T) {
                        for item in iterator {
                            self.insert(item)
                        }
                    }
                }
                impl ::bitflags::__private::core::iter::FromIterator<DescriptorFlags>
                for DescriptorFlags {
                    /// The bitwise or (`|`) of the bits in each flags value.
                    fn from_iter<
                        T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                    >(iterator: T) -> Self {
                        use ::bitflags::__private::core::iter::Extend;
                        let mut result = Self::empty();
                        result.extend(iterator);
                        result
                    }
                }
                impl DescriptorFlags {
                    /// Yield a set of contained flags values.
                    ///
                    /// Each yielded flags value will correspond to a defined named flag. Any unknown bits
                    /// will be yielded together as a final flags value.
                    #[inline]
                    pub const fn iter(&self) -> ::bitflags::iter::Iter<DescriptorFlags> {
                        ::bitflags::iter::Iter::__private_const_new(
                            <DescriptorFlags as ::bitflags::Flags>::FLAGS,
                            DescriptorFlags::from_bits_retain(self.bits()),
                            DescriptorFlags::from_bits_retain(self.bits()),
                        )
                    }
                    /// Yield a set of contained named flags values.
                    ///
                    /// This method is like [`iter`](#method.iter), except only yields bits in contained named flags.
                    /// Any unknown bits, or bits not corresponding to a contained flag will not be yielded.
                    #[inline]
                    pub const fn iter_names(
                        &self,
                    ) -> ::bitflags::iter::IterNames<DescriptorFlags> {
                        ::bitflags::iter::IterNames::__private_const_new(
                            <DescriptorFlags as ::bitflags::Flags>::FLAGS,
                            DescriptorFlags::from_bits_retain(self.bits()),
                            DescriptorFlags::from_bits_retain(self.bits()),
                        )
                    }
                }
                impl ::bitflags::__private::core::iter::IntoIterator
                for DescriptorFlags {
                    type Item = DescriptorFlags;
                    type IntoIter = ::bitflags::iter::Iter<DescriptorFlags>;
                    fn into_iter(self) -> Self::IntoIter {
                        self.iter()
                    }
                }
            };
            pub struct PathFlags(
                <PathFlags as ::bitflags::__private::PublicFlags>::Internal,
            );
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for PathFlags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for PathFlags {
                #[inline]
                fn eq(&self, other: &PathFlags) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for PathFlags {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        <PathFlags as ::bitflags::__private::PublicFlags>::Internal,
                    >;
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for PathFlags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &PathFlags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for PathFlags {
                #[inline]
                fn cmp(&self, other: &PathFlags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for PathFlags {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PathFlags {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "PathFlags",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PathFlags {
                #[inline]
                fn clone(&self) -> PathFlags {
                    let _: ::core::clone::AssertParamIsClone<
                        <PathFlags as ::bitflags::__private::PublicFlags>::Internal,
                    >;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for PathFlags {}
            impl PathFlags {
                #[allow(deprecated, non_upper_case_globals)]
                pub const SYMLINK_FOLLOW: Self = Self::from_bits_retain(1 << 0);
            }
            impl ::bitflags::Flags for PathFlags {
                const FLAGS: &'static [::bitflags::Flag<PathFlags>] = &[
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new(
                            "SYMLINK_FOLLOW",
                            PathFlags::SYMLINK_FOLLOW,
                        )
                    },
                ];
                type Bits = u8;
                fn bits(&self) -> u8 {
                    PathFlags::bits(self)
                }
                fn from_bits_retain(bits: u8) -> PathFlags {
                    PathFlags::from_bits_retain(bits)
                }
            }
            #[allow(
                dead_code,
                deprecated,
                unused_doc_comments,
                unused_attributes,
                unused_mut,
                unused_imports,
                non_upper_case_globals,
                clippy::assign_op_pattern,
                clippy::indexing_slicing,
                clippy::same_name_method,
                clippy::iter_without_into_iter,
            )]
            const _: () = {
                #[repr(transparent)]
                pub struct InternalBitFlags(u8);
                #[automatically_derived]
                impl ::core::clone::Clone for InternalBitFlags {
                    #[inline]
                    fn clone(&self) -> InternalBitFlags {
                        let _: ::core::clone::AssertParamIsClone<u8>;
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for InternalBitFlags {}
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for InternalBitFlags {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for InternalBitFlags {
                    #[inline]
                    fn eq(&self, other: &InternalBitFlags) -> bool {
                        self.0 == other.0
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::Eq for InternalBitFlags {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {
                        let _: ::core::cmp::AssertParamIsEq<u8>;
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::PartialOrd for InternalBitFlags {
                    #[inline]
                    fn partial_cmp(
                        &self,
                        other: &InternalBitFlags,
                    ) -> ::core::option::Option<::core::cmp::Ordering> {
                        ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::Ord for InternalBitFlags {
                    #[inline]
                    fn cmp(&self, other: &InternalBitFlags) -> ::core::cmp::Ordering {
                        ::core::cmp::Ord::cmp(&self.0, &other.0)
                    }
                }
                #[automatically_derived]
                impl ::core::hash::Hash for InternalBitFlags {
                    #[inline]
                    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                        ::core::hash::Hash::hash(&self.0, state)
                    }
                }
                impl ::bitflags::__private::PublicFlags for PathFlags {
                    type Primitive = u8;
                    type Internal = InternalBitFlags;
                }
                impl ::bitflags::__private::core::default::Default for InternalBitFlags {
                    #[inline]
                    fn default() -> Self {
                        InternalBitFlags::empty()
                    }
                }
                impl ::bitflags::__private::core::fmt::Debug for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        if self.is_empty() {
                            f.write_fmt(
                                format_args!("{0:#x}", <u8 as ::bitflags::Bits>::EMPTY),
                            )
                        } else {
                            ::bitflags::__private::core::fmt::Display::fmt(self, f)
                        }
                    }
                }
                impl ::bitflags::__private::core::fmt::Display for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::parser::to_writer(&PathFlags(*self), f)
                    }
                }
                impl ::bitflags::__private::core::str::FromStr for InternalBitFlags {
                    type Err = ::bitflags::parser::ParseError;
                    fn from_str(
                        s: &str,
                    ) -> ::bitflags::__private::core::result::Result<Self, Self::Err> {
                        ::bitflags::parser::from_str::<PathFlags>(s).map(|flags| flags.0)
                    }
                }
                impl ::bitflags::__private::core::convert::AsRef<u8>
                for InternalBitFlags {
                    fn as_ref(&self) -> &u8 {
                        &self.0
                    }
                }
                impl ::bitflags::__private::core::convert::From<u8>
                for InternalBitFlags {
                    fn from(bits: u8) -> Self {
                        Self::from_bits_retain(bits)
                    }
                }
                #[allow(dead_code, deprecated, unused_attributes)]
                impl InternalBitFlags {
                    /// Get a flags value with all bits unset.
                    #[inline]
                    pub const fn empty() -> Self {
                        Self(<u8 as ::bitflags::Bits>::EMPTY)
                    }
                    /// Get a flags value with all known bits set.
                    #[inline]
                    pub const fn all() -> Self {
                        let mut truncated = <u8 as ::bitflags::Bits>::EMPTY;
                        let mut i = 0;
                        {
                            {
                                let flag = <PathFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        let _ = i;
                        Self(truncated)
                    }
                    /// Get the underlying bits value.
                    ///
                    /// The returned value is exactly the bits set in this flags value.
                    #[inline]
                    pub const fn bits(&self) -> u8 {
                        self.0
                    }
                    /// Convert from a bits value.
                    ///
                    /// This method will return `None` if any unknown bits are set.
                    #[inline]
                    pub const fn from_bits(
                        bits: u8,
                    ) -> ::bitflags::__private::core::option::Option<Self> {
                        let truncated = Self::from_bits_truncate(bits).0;
                        if truncated == bits {
                            ::bitflags::__private::core::option::Option::Some(Self(bits))
                        } else {
                            ::bitflags::__private::core::option::Option::None
                        }
                    }
                    /// Convert from a bits value, unsetting any unknown bits.
                    #[inline]
                    pub const fn from_bits_truncate(bits: u8) -> Self {
                        Self(bits & Self::all().0)
                    }
                    /// Convert from a bits value exactly.
                    #[inline]
                    pub const fn from_bits_retain(bits: u8) -> Self {
                        Self(bits)
                    }
                    /// Get a flags value with the bits of a flag with the given name set.
                    ///
                    /// This method will return `None` if `name` is empty or doesn't
                    /// correspond to any named flag.
                    #[inline]
                    pub fn from_name(
                        name: &str,
                    ) -> ::bitflags::__private::core::option::Option<Self> {
                        {
                            if name == "SYMLINK_FOLLOW" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(PathFlags::SYMLINK_FOLLOW.bits()),
                                );
                            }
                        };
                        let _ = name;
                        ::bitflags::__private::core::option::Option::None
                    }
                    /// Whether all bits in this flags value are unset.
                    #[inline]
                    pub const fn is_empty(&self) -> bool {
                        self.0 == <u8 as ::bitflags::Bits>::EMPTY
                    }
                    /// Whether all known bits in this flags value are set.
                    #[inline]
                    pub const fn is_all(&self) -> bool {
                        Self::all().0 | self.0 == self.0
                    }
                    /// Whether any set bits in a source flags value are also set in a target flags value.
                    #[inline]
                    pub const fn intersects(&self, other: Self) -> bool {
                        self.0 & other.0 != <u8 as ::bitflags::Bits>::EMPTY
                    }
                    /// Whether all set bits in a source flags value are also set in a target flags value.
                    #[inline]
                    pub const fn contains(&self, other: Self) -> bool {
                        self.0 & other.0 == other.0
                    }
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    pub fn insert(&mut self, other: Self) {
                        *self = Self(self.0).union(other);
                    }
                    /// The intersection of a source flags value with the complement of a target flags
                    /// value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `remove` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    pub fn remove(&mut self, other: Self) {
                        *self = Self(self.0).difference(other);
                    }
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    pub fn toggle(&mut self, other: Self) {
                        *self = Self(self.0).symmetric_difference(other);
                    }
                    /// Call `insert` when `value` is `true` or `remove` when `value` is `false`.
                    #[inline]
                    pub fn set(&mut self, other: Self, value: bool) {
                        if value {
                            self.insert(other);
                        } else {
                            self.remove(other);
                        }
                    }
                    /// The bitwise and (`&`) of the bits in two flags values.
                    #[inline]
                    #[must_use]
                    pub const fn intersection(self, other: Self) -> Self {
                        Self(self.0 & other.0)
                    }
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    #[must_use]
                    pub const fn union(self, other: Self) -> Self {
                        Self(self.0 | other.0)
                    }
                    /// The intersection of a source flags value with the complement of a target flags
                    /// value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `difference` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    #[must_use]
                    pub const fn difference(self, other: Self) -> Self {
                        Self(self.0 & !other.0)
                    }
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    #[must_use]
                    pub const fn symmetric_difference(self, other: Self) -> Self {
                        Self(self.0 ^ other.0)
                    }
                    /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                    #[inline]
                    #[must_use]
                    pub const fn complement(self) -> Self {
                        Self::from_bits_truncate(!self.0)
                    }
                }
                impl ::bitflags::__private::core::fmt::Binary for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::Binary::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::Octal for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::Octal::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::LowerHex for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::LowerHex::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::UpperHex for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::UpperHex::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::ops::BitOr for InternalBitFlags {
                    type Output = Self;
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    fn bitor(self, other: InternalBitFlags) -> Self {
                        self.union(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitOrAssign for InternalBitFlags {
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    fn bitor_assign(&mut self, other: Self) {
                        self.insert(other);
                    }
                }
                impl ::bitflags::__private::core::ops::BitXor for InternalBitFlags {
                    type Output = Self;
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    fn bitxor(self, other: Self) -> Self {
                        self.symmetric_difference(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitXorAssign
                for InternalBitFlags {
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    fn bitxor_assign(&mut self, other: Self) {
                        self.toggle(other);
                    }
                }
                impl ::bitflags::__private::core::ops::BitAnd for InternalBitFlags {
                    type Output = Self;
                    /// The bitwise and (`&`) of the bits in two flags values.
                    #[inline]
                    fn bitand(self, other: Self) -> Self {
                        self.intersection(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitAndAssign
                for InternalBitFlags {
                    /// The bitwise and (`&`) of the bits in two flags values.
                    #[inline]
                    fn bitand_assign(&mut self, other: Self) {
                        *self = Self::from_bits_retain(self.bits()).intersection(other);
                    }
                }
                impl ::bitflags::__private::core::ops::Sub for InternalBitFlags {
                    type Output = Self;
                    /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `difference` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    fn sub(self, other: Self) -> Self {
                        self.difference(other)
                    }
                }
                impl ::bitflags::__private::core::ops::SubAssign for InternalBitFlags {
                    /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `difference` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    fn sub_assign(&mut self, other: Self) {
                        self.remove(other);
                    }
                }
                impl ::bitflags::__private::core::ops::Not for InternalBitFlags {
                    type Output = Self;
                    /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                    #[inline]
                    fn not(self) -> Self {
                        self.complement()
                    }
                }
                impl ::bitflags::__private::core::iter::Extend<InternalBitFlags>
                for InternalBitFlags {
                    /// The bitwise or (`|`) of the bits in each flags value.
                    fn extend<
                        T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                    >(&mut self, iterator: T) {
                        for item in iterator {
                            self.insert(item)
                        }
                    }
                }
                impl ::bitflags::__private::core::iter::FromIterator<InternalBitFlags>
                for InternalBitFlags {
                    /// The bitwise or (`|`) of the bits in each flags value.
                    fn from_iter<
                        T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                    >(iterator: T) -> Self {
                        use ::bitflags::__private::core::iter::Extend;
                        let mut result = Self::empty();
                        result.extend(iterator);
                        result
                    }
                }
                impl InternalBitFlags {
                    /// Yield a set of contained flags values.
                    ///
                    /// Each yielded flags value will correspond to a defined named flag. Any unknown bits
                    /// will be yielded together as a final flags value.
                    #[inline]
                    pub const fn iter(&self) -> ::bitflags::iter::Iter<PathFlags> {
                        ::bitflags::iter::Iter::__private_const_new(
                            <PathFlags as ::bitflags::Flags>::FLAGS,
                            PathFlags::from_bits_retain(self.bits()),
                            PathFlags::from_bits_retain(self.bits()),
                        )
                    }
                    /// Yield a set of contained named flags values.
                    ///
                    /// This method is like [`iter`](#method.iter), except only yields bits in contained named flags.
                    /// Any unknown bits, or bits not corresponding to a contained flag will not be yielded.
                    #[inline]
                    pub const fn iter_names(
                        &self,
                    ) -> ::bitflags::iter::IterNames<PathFlags> {
                        ::bitflags::iter::IterNames::__private_const_new(
                            <PathFlags as ::bitflags::Flags>::FLAGS,
                            PathFlags::from_bits_retain(self.bits()),
                            PathFlags::from_bits_retain(self.bits()),
                        )
                    }
                }
                impl ::bitflags::__private::core::iter::IntoIterator
                for InternalBitFlags {
                    type Item = PathFlags;
                    type IntoIter = ::bitflags::iter::Iter<PathFlags>;
                    fn into_iter(self) -> Self::IntoIter {
                        self.iter()
                    }
                }
                impl InternalBitFlags {
                    /// Returns a mutable reference to the raw value of the flags currently stored.
                    #[inline]
                    pub fn bits_mut(&mut self) -> &mut u8 {
                        &mut self.0
                    }
                }
                #[allow(dead_code, deprecated, unused_attributes)]
                impl PathFlags {
                    /// Get a flags value with all bits unset.
                    #[inline]
                    pub const fn empty() -> Self {
                        Self(InternalBitFlags::empty())
                    }
                    /// Get a flags value with all known bits set.
                    #[inline]
                    pub const fn all() -> Self {
                        Self(InternalBitFlags::all())
                    }
                    /// Get the underlying bits value.
                    ///
                    /// The returned value is exactly the bits set in this flags value.
                    #[inline]
                    pub const fn bits(&self) -> u8 {
                        self.0.bits()
                    }
                    /// Convert from a bits value.
                    ///
                    /// This method will return `None` if any unknown bits are set.
                    #[inline]
                    pub const fn from_bits(
                        bits: u8,
                    ) -> ::bitflags::__private::core::option::Option<Self> {
                        match InternalBitFlags::from_bits(bits) {
                            ::bitflags::__private::core::option::Option::Some(bits) => {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            }
                            ::bitflags::__private::core::option::Option::None => {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                    /// Convert from a bits value, unsetting any unknown bits.
                    #[inline]
                    pub const fn from_bits_truncate(bits: u8) -> Self {
                        Self(InternalBitFlags::from_bits_truncate(bits))
                    }
                    /// Convert from a bits value exactly.
                    #[inline]
                    pub const fn from_bits_retain(bits: u8) -> Self {
                        Self(InternalBitFlags::from_bits_retain(bits))
                    }
                    /// Get a flags value with the bits of a flag with the given name set.
                    ///
                    /// This method will return `None` if `name` is empty or doesn't
                    /// correspond to any named flag.
                    #[inline]
                    pub fn from_name(
                        name: &str,
                    ) -> ::bitflags::__private::core::option::Option<Self> {
                        match InternalBitFlags::from_name(name) {
                            ::bitflags::__private::core::option::Option::Some(bits) => {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            }
                            ::bitflags::__private::core::option::Option::None => {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                    /// Whether all bits in this flags value are unset.
                    #[inline]
                    pub const fn is_empty(&self) -> bool {
                        self.0.is_empty()
                    }
                    /// Whether all known bits in this flags value are set.
                    #[inline]
                    pub const fn is_all(&self) -> bool {
                        self.0.is_all()
                    }
                    /// Whether any set bits in a source flags value are also set in a target flags value.
                    #[inline]
                    pub const fn intersects(&self, other: Self) -> bool {
                        self.0.intersects(other.0)
                    }
                    /// Whether all set bits in a source flags value are also set in a target flags value.
                    #[inline]
                    pub const fn contains(&self, other: Self) -> bool {
                        self.0.contains(other.0)
                    }
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    pub fn insert(&mut self, other: Self) {
                        self.0.insert(other.0)
                    }
                    /// The intersection of a source flags value with the complement of a target flags
                    /// value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `remove` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    pub fn remove(&mut self, other: Self) {
                        self.0.remove(other.0)
                    }
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    pub fn toggle(&mut self, other: Self) {
                        self.0.toggle(other.0)
                    }
                    /// Call `insert` when `value` is `true` or `remove` when `value` is `false`.
                    #[inline]
                    pub fn set(&mut self, other: Self, value: bool) {
                        self.0.set(other.0, value)
                    }
                    /// The bitwise and (`&`) of the bits in two flags values.
                    #[inline]
                    #[must_use]
                    pub const fn intersection(self, other: Self) -> Self {
                        Self(self.0.intersection(other.0))
                    }
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    #[must_use]
                    pub const fn union(self, other: Self) -> Self {
                        Self(self.0.union(other.0))
                    }
                    /// The intersection of a source flags value with the complement of a target flags
                    /// value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `difference` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    #[must_use]
                    pub const fn difference(self, other: Self) -> Self {
                        Self(self.0.difference(other.0))
                    }
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    #[must_use]
                    pub const fn symmetric_difference(self, other: Self) -> Self {
                        Self(self.0.symmetric_difference(other.0))
                    }
                    /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                    #[inline]
                    #[must_use]
                    pub const fn complement(self) -> Self {
                        Self(self.0.complement())
                    }
                }
                impl ::bitflags::__private::core::fmt::Binary for PathFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::Binary::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::Octal for PathFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::Octal::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::LowerHex for PathFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::LowerHex::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::UpperHex for PathFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::UpperHex::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::ops::BitOr for PathFlags {
                    type Output = Self;
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    fn bitor(self, other: PathFlags) -> Self {
                        self.union(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitOrAssign for PathFlags {
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    fn bitor_assign(&mut self, other: Self) {
                        self.insert(other);
                    }
                }
                impl ::bitflags::__private::core::ops::BitXor for PathFlags {
                    type Output = Self;
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    fn bitxor(self, other: Self) -> Self {
                        self.symmetric_difference(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitXorAssign for PathFlags {
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    fn bitxor_assign(&mut self, other: Self) {
                        self.toggle(other);
                    }
                }
                impl ::bitflags::__private::core::ops::BitAnd for PathFlags {
                    type Output = Self;
                    /// The bitwise and (`&`) of the bits in two flags values.
                    #[inline]
                    fn bitand(self, other: Self) -> Self {
                        self.intersection(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitAndAssign for PathFlags {
                    /// The bitwise and (`&`) of the bits in two flags values.
                    #[inline]
                    fn bitand_assign(&mut self, other: Self) {
                        *self = Self::from_bits_retain(self.bits()).intersection(other);
                    }
                }
                impl ::bitflags::__private::core::ops::Sub for PathFlags {
                    type Output = Self;
                    /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `difference` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    fn sub(self, other: Self) -> Self {
                        self.difference(other)
                    }
                }
                impl ::bitflags::__private::core::ops::SubAssign for PathFlags {
                    /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `difference` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    fn sub_assign(&mut self, other: Self) {
                        self.remove(other);
                    }
                }
                impl ::bitflags::__private::core::ops::Not for PathFlags {
                    type Output = Self;
                    /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                    #[inline]
                    fn not(self) -> Self {
                        self.complement()
                    }
                }
                impl ::bitflags::__private::core::iter::Extend<PathFlags> for PathFlags {
                    /// The bitwise or (`|`) of the bits in each flags value.
                    fn extend<
                        T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                    >(&mut self, iterator: T) {
                        for item in iterator {
                            self.insert(item)
                        }
                    }
                }
                impl ::bitflags::__private::core::iter::FromIterator<PathFlags>
                for PathFlags {
                    /// The bitwise or (`|`) of the bits in each flags value.
                    fn from_iter<
                        T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                    >(iterator: T) -> Self {
                        use ::bitflags::__private::core::iter::Extend;
                        let mut result = Self::empty();
                        result.extend(iterator);
                        result
                    }
                }
                impl PathFlags {
                    /// Yield a set of contained flags values.
                    ///
                    /// Each yielded flags value will correspond to a defined named flag. Any unknown bits
                    /// will be yielded together as a final flags value.
                    #[inline]
                    pub const fn iter(&self) -> ::bitflags::iter::Iter<PathFlags> {
                        ::bitflags::iter::Iter::__private_const_new(
                            <PathFlags as ::bitflags::Flags>::FLAGS,
                            PathFlags::from_bits_retain(self.bits()),
                            PathFlags::from_bits_retain(self.bits()),
                        )
                    }
                    /// Yield a set of contained named flags values.
                    ///
                    /// This method is like [`iter`](#method.iter), except only yields bits in contained named flags.
                    /// Any unknown bits, or bits not corresponding to a contained flag will not be yielded.
                    #[inline]
                    pub const fn iter_names(
                        &self,
                    ) -> ::bitflags::iter::IterNames<PathFlags> {
                        ::bitflags::iter::IterNames::__private_const_new(
                            <PathFlags as ::bitflags::Flags>::FLAGS,
                            PathFlags::from_bits_retain(self.bits()),
                            PathFlags::from_bits_retain(self.bits()),
                        )
                    }
                }
                impl ::bitflags::__private::core::iter::IntoIterator for PathFlags {
                    type Item = PathFlags;
                    type IntoIter = ::bitflags::iter::Iter<PathFlags>;
                    fn into_iter(self) -> Self::IntoIter {
                        self.iter()
                    }
                }
            };
            pub struct OpenFlags(
                <OpenFlags as ::bitflags::__private::PublicFlags>::Internal,
            );
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for OpenFlags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for OpenFlags {
                #[inline]
                fn eq(&self, other: &OpenFlags) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for OpenFlags {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        <OpenFlags as ::bitflags::__private::PublicFlags>::Internal,
                    >;
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for OpenFlags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &OpenFlags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for OpenFlags {
                #[inline]
                fn cmp(&self, other: &OpenFlags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for OpenFlags {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for OpenFlags {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "OpenFlags",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for OpenFlags {
                #[inline]
                fn clone(&self) -> OpenFlags {
                    let _: ::core::clone::AssertParamIsClone<
                        <OpenFlags as ::bitflags::__private::PublicFlags>::Internal,
                    >;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for OpenFlags {}
            impl OpenFlags {
                #[allow(deprecated, non_upper_case_globals)]
                pub const CREATE: Self = Self::from_bits_retain(1 << 0);
                #[allow(deprecated, non_upper_case_globals)]
                pub const DIRECTORY: Self = Self::from_bits_retain(1 << 1);
                #[allow(deprecated, non_upper_case_globals)]
                pub const EXCLUSIVE: Self = Self::from_bits_retain(1 << 2);
                #[allow(deprecated, non_upper_case_globals)]
                pub const TRUNCATE: Self = Self::from_bits_retain(1 << 3);
            }
            impl ::bitflags::Flags for OpenFlags {
                const FLAGS: &'static [::bitflags::Flag<OpenFlags>] = &[
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new("CREATE", OpenFlags::CREATE)
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new("DIRECTORY", OpenFlags::DIRECTORY)
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new("EXCLUSIVE", OpenFlags::EXCLUSIVE)
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new("TRUNCATE", OpenFlags::TRUNCATE)
                    },
                ];
                type Bits = u8;
                fn bits(&self) -> u8 {
                    OpenFlags::bits(self)
                }
                fn from_bits_retain(bits: u8) -> OpenFlags {
                    OpenFlags::from_bits_retain(bits)
                }
            }
            #[allow(
                dead_code,
                deprecated,
                unused_doc_comments,
                unused_attributes,
                unused_mut,
                unused_imports,
                non_upper_case_globals,
                clippy::assign_op_pattern,
                clippy::indexing_slicing,
                clippy::same_name_method,
                clippy::iter_without_into_iter,
            )]
            const _: () = {
                #[repr(transparent)]
                pub struct InternalBitFlags(u8);
                #[automatically_derived]
                impl ::core::clone::Clone for InternalBitFlags {
                    #[inline]
                    fn clone(&self) -> InternalBitFlags {
                        let _: ::core::clone::AssertParamIsClone<u8>;
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for InternalBitFlags {}
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for InternalBitFlags {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for InternalBitFlags {
                    #[inline]
                    fn eq(&self, other: &InternalBitFlags) -> bool {
                        self.0 == other.0
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::Eq for InternalBitFlags {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {
                        let _: ::core::cmp::AssertParamIsEq<u8>;
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::PartialOrd for InternalBitFlags {
                    #[inline]
                    fn partial_cmp(
                        &self,
                        other: &InternalBitFlags,
                    ) -> ::core::option::Option<::core::cmp::Ordering> {
                        ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::Ord for InternalBitFlags {
                    #[inline]
                    fn cmp(&self, other: &InternalBitFlags) -> ::core::cmp::Ordering {
                        ::core::cmp::Ord::cmp(&self.0, &other.0)
                    }
                }
                #[automatically_derived]
                impl ::core::hash::Hash for InternalBitFlags {
                    #[inline]
                    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                        ::core::hash::Hash::hash(&self.0, state)
                    }
                }
                impl ::bitflags::__private::PublicFlags for OpenFlags {
                    type Primitive = u8;
                    type Internal = InternalBitFlags;
                }
                impl ::bitflags::__private::core::default::Default for InternalBitFlags {
                    #[inline]
                    fn default() -> Self {
                        InternalBitFlags::empty()
                    }
                }
                impl ::bitflags::__private::core::fmt::Debug for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        if self.is_empty() {
                            f.write_fmt(
                                format_args!("{0:#x}", <u8 as ::bitflags::Bits>::EMPTY),
                            )
                        } else {
                            ::bitflags::__private::core::fmt::Display::fmt(self, f)
                        }
                    }
                }
                impl ::bitflags::__private::core::fmt::Display for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::parser::to_writer(&OpenFlags(*self), f)
                    }
                }
                impl ::bitflags::__private::core::str::FromStr for InternalBitFlags {
                    type Err = ::bitflags::parser::ParseError;
                    fn from_str(
                        s: &str,
                    ) -> ::bitflags::__private::core::result::Result<Self, Self::Err> {
                        ::bitflags::parser::from_str::<OpenFlags>(s).map(|flags| flags.0)
                    }
                }
                impl ::bitflags::__private::core::convert::AsRef<u8>
                for InternalBitFlags {
                    fn as_ref(&self) -> &u8 {
                        &self.0
                    }
                }
                impl ::bitflags::__private::core::convert::From<u8>
                for InternalBitFlags {
                    fn from(bits: u8) -> Self {
                        Self::from_bits_retain(bits)
                    }
                }
                #[allow(dead_code, deprecated, unused_attributes)]
                impl InternalBitFlags {
                    /// Get a flags value with all bits unset.
                    #[inline]
                    pub const fn empty() -> Self {
                        Self(<u8 as ::bitflags::Bits>::EMPTY)
                    }
                    /// Get a flags value with all known bits set.
                    #[inline]
                    pub const fn all() -> Self {
                        let mut truncated = <u8 as ::bitflags::Bits>::EMPTY;
                        let mut i = 0;
                        {
                            {
                                let flag = <OpenFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        {
                            {
                                let flag = <OpenFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        {
                            {
                                let flag = <OpenFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        {
                            {
                                let flag = <OpenFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        let _ = i;
                        Self(truncated)
                    }
                    /// Get the underlying bits value.
                    ///
                    /// The returned value is exactly the bits set in this flags value.
                    #[inline]
                    pub const fn bits(&self) -> u8 {
                        self.0
                    }
                    /// Convert from a bits value.
                    ///
                    /// This method will return `None` if any unknown bits are set.
                    #[inline]
                    pub const fn from_bits(
                        bits: u8,
                    ) -> ::bitflags::__private::core::option::Option<Self> {
                        let truncated = Self::from_bits_truncate(bits).0;
                        if truncated == bits {
                            ::bitflags::__private::core::option::Option::Some(Self(bits))
                        } else {
                            ::bitflags::__private::core::option::Option::None
                        }
                    }
                    /// Convert from a bits value, unsetting any unknown bits.
                    #[inline]
                    pub const fn from_bits_truncate(bits: u8) -> Self {
                        Self(bits & Self::all().0)
                    }
                    /// Convert from a bits value exactly.
                    #[inline]
                    pub const fn from_bits_retain(bits: u8) -> Self {
                        Self(bits)
                    }
                    /// Get a flags value with the bits of a flag with the given name set.
                    ///
                    /// This method will return `None` if `name` is empty or doesn't
                    /// correspond to any named flag.
                    #[inline]
                    pub fn from_name(
                        name: &str,
                    ) -> ::bitflags::__private::core::option::Option<Self> {
                        {
                            if name == "CREATE" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(OpenFlags::CREATE.bits()),
                                );
                            }
                        };
                        {
                            if name == "DIRECTORY" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(OpenFlags::DIRECTORY.bits()),
                                );
                            }
                        };
                        {
                            if name == "EXCLUSIVE" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(OpenFlags::EXCLUSIVE.bits()),
                                );
                            }
                        };
                        {
                            if name == "TRUNCATE" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(OpenFlags::TRUNCATE.bits()),
                                );
                            }
                        };
                        let _ = name;
                        ::bitflags::__private::core::option::Option::None
                    }
                    /// Whether all bits in this flags value are unset.
                    #[inline]
                    pub const fn is_empty(&self) -> bool {
                        self.0 == <u8 as ::bitflags::Bits>::EMPTY
                    }
                    /// Whether all known bits in this flags value are set.
                    #[inline]
                    pub const fn is_all(&self) -> bool {
                        Self::all().0 | self.0 == self.0
                    }
                    /// Whether any set bits in a source flags value are also set in a target flags value.
                    #[inline]
                    pub const fn intersects(&self, other: Self) -> bool {
                        self.0 & other.0 != <u8 as ::bitflags::Bits>::EMPTY
                    }
                    /// Whether all set bits in a source flags value are also set in a target flags value.
                    #[inline]
                    pub const fn contains(&self, other: Self) -> bool {
                        self.0 & other.0 == other.0
                    }
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    pub fn insert(&mut self, other: Self) {
                        *self = Self(self.0).union(other);
                    }
                    /// The intersection of a source flags value with the complement of a target flags
                    /// value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `remove` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    pub fn remove(&mut self, other: Self) {
                        *self = Self(self.0).difference(other);
                    }
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    pub fn toggle(&mut self, other: Self) {
                        *self = Self(self.0).symmetric_difference(other);
                    }
                    /// Call `insert` when `value` is `true` or `remove` when `value` is `false`.
                    #[inline]
                    pub fn set(&mut self, other: Self, value: bool) {
                        if value {
                            self.insert(other);
                        } else {
                            self.remove(other);
                        }
                    }
                    /// The bitwise and (`&`) of the bits in two flags values.
                    #[inline]
                    #[must_use]
                    pub const fn intersection(self, other: Self) -> Self {
                        Self(self.0 & other.0)
                    }
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    #[must_use]
                    pub const fn union(self, other: Self) -> Self {
                        Self(self.0 | other.0)
                    }
                    /// The intersection of a source flags value with the complement of a target flags
                    /// value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `difference` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    #[must_use]
                    pub const fn difference(self, other: Self) -> Self {
                        Self(self.0 & !other.0)
                    }
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    #[must_use]
                    pub const fn symmetric_difference(self, other: Self) -> Self {
                        Self(self.0 ^ other.0)
                    }
                    /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                    #[inline]
                    #[must_use]
                    pub const fn complement(self) -> Self {
                        Self::from_bits_truncate(!self.0)
                    }
                }
                impl ::bitflags::__private::core::fmt::Binary for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::Binary::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::Octal for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::Octal::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::LowerHex for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::LowerHex::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::UpperHex for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::UpperHex::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::ops::BitOr for InternalBitFlags {
                    type Output = Self;
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    fn bitor(self, other: InternalBitFlags) -> Self {
                        self.union(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitOrAssign for InternalBitFlags {
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    fn bitor_assign(&mut self, other: Self) {
                        self.insert(other);
                    }
                }
                impl ::bitflags::__private::core::ops::BitXor for InternalBitFlags {
                    type Output = Self;
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    fn bitxor(self, other: Self) -> Self {
                        self.symmetric_difference(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitXorAssign
                for InternalBitFlags {
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    fn bitxor_assign(&mut self, other: Self) {
                        self.toggle(other);
                    }
                }
                impl ::bitflags::__private::core::ops::BitAnd for InternalBitFlags {
                    type Output = Self;
                    /// The bitwise and (`&`) of the bits in two flags values.
                    #[inline]
                    fn bitand(self, other: Self) -> Self {
                        self.intersection(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitAndAssign
                for InternalBitFlags {
                    /// The bitwise and (`&`) of the bits in two flags values.
                    #[inline]
                    fn bitand_assign(&mut self, other: Self) {
                        *self = Self::from_bits_retain(self.bits()).intersection(other);
                    }
                }
                impl ::bitflags::__private::core::ops::Sub for InternalBitFlags {
                    type Output = Self;
                    /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `difference` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    fn sub(self, other: Self) -> Self {
                        self.difference(other)
                    }
                }
                impl ::bitflags::__private::core::ops::SubAssign for InternalBitFlags {
                    /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `difference` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    fn sub_assign(&mut self, other: Self) {
                        self.remove(other);
                    }
                }
                impl ::bitflags::__private::core::ops::Not for InternalBitFlags {
                    type Output = Self;
                    /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                    #[inline]
                    fn not(self) -> Self {
                        self.complement()
                    }
                }
                impl ::bitflags::__private::core::iter::Extend<InternalBitFlags>
                for InternalBitFlags {
                    /// The bitwise or (`|`) of the bits in each flags value.
                    fn extend<
                        T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                    >(&mut self, iterator: T) {
                        for item in iterator {
                            self.insert(item)
                        }
                    }
                }
                impl ::bitflags::__private::core::iter::FromIterator<InternalBitFlags>
                for InternalBitFlags {
                    /// The bitwise or (`|`) of the bits in each flags value.
                    fn from_iter<
                        T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                    >(iterator: T) -> Self {
                        use ::bitflags::__private::core::iter::Extend;
                        let mut result = Self::empty();
                        result.extend(iterator);
                        result
                    }
                }
                impl InternalBitFlags {
                    /// Yield a set of contained flags values.
                    ///
                    /// Each yielded flags value will correspond to a defined named flag. Any unknown bits
                    /// will be yielded together as a final flags value.
                    #[inline]
                    pub const fn iter(&self) -> ::bitflags::iter::Iter<OpenFlags> {
                        ::bitflags::iter::Iter::__private_const_new(
                            <OpenFlags as ::bitflags::Flags>::FLAGS,
                            OpenFlags::from_bits_retain(self.bits()),
                            OpenFlags::from_bits_retain(self.bits()),
                        )
                    }
                    /// Yield a set of contained named flags values.
                    ///
                    /// This method is like [`iter`](#method.iter), except only yields bits in contained named flags.
                    /// Any unknown bits, or bits not corresponding to a contained flag will not be yielded.
                    #[inline]
                    pub const fn iter_names(
                        &self,
                    ) -> ::bitflags::iter::IterNames<OpenFlags> {
                        ::bitflags::iter::IterNames::__private_const_new(
                            <OpenFlags as ::bitflags::Flags>::FLAGS,
                            OpenFlags::from_bits_retain(self.bits()),
                            OpenFlags::from_bits_retain(self.bits()),
                        )
                    }
                }
                impl ::bitflags::__private::core::iter::IntoIterator
                for InternalBitFlags {
                    type Item = OpenFlags;
                    type IntoIter = ::bitflags::iter::Iter<OpenFlags>;
                    fn into_iter(self) -> Self::IntoIter {
                        self.iter()
                    }
                }
                impl InternalBitFlags {
                    /// Returns a mutable reference to the raw value of the flags currently stored.
                    #[inline]
                    pub fn bits_mut(&mut self) -> &mut u8 {
                        &mut self.0
                    }
                }
                #[allow(dead_code, deprecated, unused_attributes)]
                impl OpenFlags {
                    /// Get a flags value with all bits unset.
                    #[inline]
                    pub const fn empty() -> Self {
                        Self(InternalBitFlags::empty())
                    }
                    /// Get a flags value with all known bits set.
                    #[inline]
                    pub const fn all() -> Self {
                        Self(InternalBitFlags::all())
                    }
                    /// Get the underlying bits value.
                    ///
                    /// The returned value is exactly the bits set in this flags value.
                    #[inline]
                    pub const fn bits(&self) -> u8 {
                        self.0.bits()
                    }
                    /// Convert from a bits value.
                    ///
                    /// This method will return `None` if any unknown bits are set.
                    #[inline]
                    pub const fn from_bits(
                        bits: u8,
                    ) -> ::bitflags::__private::core::option::Option<Self> {
                        match InternalBitFlags::from_bits(bits) {
                            ::bitflags::__private::core::option::Option::Some(bits) => {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            }
                            ::bitflags::__private::core::option::Option::None => {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                    /// Convert from a bits value, unsetting any unknown bits.
                    #[inline]
                    pub const fn from_bits_truncate(bits: u8) -> Self {
                        Self(InternalBitFlags::from_bits_truncate(bits))
                    }
                    /// Convert from a bits value exactly.
                    #[inline]
                    pub const fn from_bits_retain(bits: u8) -> Self {
                        Self(InternalBitFlags::from_bits_retain(bits))
                    }
                    /// Get a flags value with the bits of a flag with the given name set.
                    ///
                    /// This method will return `None` if `name` is empty or doesn't
                    /// correspond to any named flag.
                    #[inline]
                    pub fn from_name(
                        name: &str,
                    ) -> ::bitflags::__private::core::option::Option<Self> {
                        match InternalBitFlags::from_name(name) {
                            ::bitflags::__private::core::option::Option::Some(bits) => {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            }
                            ::bitflags::__private::core::option::Option::None => {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                    /// Whether all bits in this flags value are unset.
                    #[inline]
                    pub const fn is_empty(&self) -> bool {
                        self.0.is_empty()
                    }
                    /// Whether all known bits in this flags value are set.
                    #[inline]
                    pub const fn is_all(&self) -> bool {
                        self.0.is_all()
                    }
                    /// Whether any set bits in a source flags value are also set in a target flags value.
                    #[inline]
                    pub const fn intersects(&self, other: Self) -> bool {
                        self.0.intersects(other.0)
                    }
                    /// Whether all set bits in a source flags value are also set in a target flags value.
                    #[inline]
                    pub const fn contains(&self, other: Self) -> bool {
                        self.0.contains(other.0)
                    }
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    pub fn insert(&mut self, other: Self) {
                        self.0.insert(other.0)
                    }
                    /// The intersection of a source flags value with the complement of a target flags
                    /// value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `remove` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    pub fn remove(&mut self, other: Self) {
                        self.0.remove(other.0)
                    }
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    pub fn toggle(&mut self, other: Self) {
                        self.0.toggle(other.0)
                    }
                    /// Call `insert` when `value` is `true` or `remove` when `value` is `false`.
                    #[inline]
                    pub fn set(&mut self, other: Self, value: bool) {
                        self.0.set(other.0, value)
                    }
                    /// The bitwise and (`&`) of the bits in two flags values.
                    #[inline]
                    #[must_use]
                    pub const fn intersection(self, other: Self) -> Self {
                        Self(self.0.intersection(other.0))
                    }
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    #[must_use]
                    pub const fn union(self, other: Self) -> Self {
                        Self(self.0.union(other.0))
                    }
                    /// The intersection of a source flags value with the complement of a target flags
                    /// value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `difference` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    #[must_use]
                    pub const fn difference(self, other: Self) -> Self {
                        Self(self.0.difference(other.0))
                    }
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    #[must_use]
                    pub const fn symmetric_difference(self, other: Self) -> Self {
                        Self(self.0.symmetric_difference(other.0))
                    }
                    /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                    #[inline]
                    #[must_use]
                    pub const fn complement(self) -> Self {
                        Self(self.0.complement())
                    }
                }
                impl ::bitflags::__private::core::fmt::Binary for OpenFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::Binary::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::Octal for OpenFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::Octal::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::LowerHex for OpenFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::LowerHex::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::UpperHex for OpenFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        let inner = self.0;
                        ::bitflags::__private::core::fmt::UpperHex::fmt(&inner, f)
                    }
                }
                impl ::bitflags::__private::core::ops::BitOr for OpenFlags {
                    type Output = Self;
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    fn bitor(self, other: OpenFlags) -> Self {
                        self.union(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitOrAssign for OpenFlags {
                    /// The bitwise or (`|`) of the bits in two flags values.
                    #[inline]
                    fn bitor_assign(&mut self, other: Self) {
                        self.insert(other);
                    }
                }
                impl ::bitflags::__private::core::ops::BitXor for OpenFlags {
                    type Output = Self;
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    fn bitxor(self, other: Self) -> Self {
                        self.symmetric_difference(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitXorAssign for OpenFlags {
                    /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                    #[inline]
                    fn bitxor_assign(&mut self, other: Self) {
                        self.toggle(other);
                    }
                }
                impl ::bitflags::__private::core::ops::BitAnd for OpenFlags {
                    type Output = Self;
                    /// The bitwise and (`&`) of the bits in two flags values.
                    #[inline]
                    fn bitand(self, other: Self) -> Self {
                        self.intersection(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitAndAssign for OpenFlags {
                    /// The bitwise and (`&`) of the bits in two flags values.
                    #[inline]
                    fn bitand_assign(&mut self, other: Self) {
                        *self = Self::from_bits_retain(self.bits()).intersection(other);
                    }
                }
                impl ::bitflags::__private::core::ops::Sub for OpenFlags {
                    type Output = Self;
                    /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `difference` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    fn sub(self, other: Self) -> Self {
                        self.difference(other)
                    }
                }
                impl ::bitflags::__private::core::ops::SubAssign for OpenFlags {
                    /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                    ///
                    /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                    /// `difference` won't truncate `other`, but the `!` operator will.
                    #[inline]
                    fn sub_assign(&mut self, other: Self) {
                        self.remove(other);
                    }
                }
                impl ::bitflags::__private::core::ops::Not for OpenFlags {
                    type Output = Self;
                    /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                    #[inline]
                    fn not(self) -> Self {
                        self.complement()
                    }
                }
                impl ::bitflags::__private::core::iter::Extend<OpenFlags> for OpenFlags {
                    /// The bitwise or (`|`) of the bits in each flags value.
                    fn extend<
                        T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                    >(&mut self, iterator: T) {
                        for item in iterator {
                            self.insert(item)
                        }
                    }
                }
                impl ::bitflags::__private::core::iter::FromIterator<OpenFlags>
                for OpenFlags {
                    /// The bitwise or (`|`) of the bits in each flags value.
                    fn from_iter<
                        T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                    >(iterator: T) -> Self {
                        use ::bitflags::__private::core::iter::Extend;
                        let mut result = Self::empty();
                        result.extend(iterator);
                        result
                    }
                }
                impl OpenFlags {
                    /// Yield a set of contained flags values.
                    ///
                    /// Each yielded flags value will correspond to a defined named flag. Any unknown bits
                    /// will be yielded together as a final flags value.
                    #[inline]
                    pub const fn iter(&self) -> ::bitflags::iter::Iter<OpenFlags> {
                        ::bitflags::iter::Iter::__private_const_new(
                            <OpenFlags as ::bitflags::Flags>::FLAGS,
                            OpenFlags::from_bits_retain(self.bits()),
                            OpenFlags::from_bits_retain(self.bits()),
                        )
                    }
                    /// Yield a set of contained named flags values.
                    ///
                    /// This method is like [`iter`](#method.iter), except only yields bits in contained named flags.
                    /// Any unknown bits, or bits not corresponding to a contained flag will not be yielded.
                    #[inline]
                    pub const fn iter_names(
                        &self,
                    ) -> ::bitflags::iter::IterNames<OpenFlags> {
                        ::bitflags::iter::IterNames::__private_const_new(
                            <OpenFlags as ::bitflags::Flags>::FLAGS,
                            OpenFlags::from_bits_retain(self.bits()),
                            OpenFlags::from_bits_retain(self.bits()),
                        )
                    }
                }
                impl ::bitflags::__private::core::iter::IntoIterator for OpenFlags {
                    type Item = OpenFlags;
                    type IntoIter = ::bitflags::iter::Iter<OpenFlags>;
                    fn into_iter(self) -> Self::IntoIter {
                        self.iter()
                    }
                }
            };
            pub type LinkCount = u64;
            #[repr(C)]
            pub struct DescriptorStat {
                pub type_: DescriptorType,
                pub link_count: LinkCount,
                pub size: Filesize,
                pub data_access_timestamp: Option<Datetime>,
                pub data_modification_timestamp: Option<Datetime>,
                pub status_change_timestamp: Option<Datetime>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for DescriptorStat {
                #[inline]
                fn clone(&self) -> DescriptorStat {
                    let _: ::core::clone::AssertParamIsClone<DescriptorType>;
                    let _: ::core::clone::AssertParamIsClone<LinkCount>;
                    let _: ::core::clone::AssertParamIsClone<Filesize>;
                    let _: ::core::clone::AssertParamIsClone<Option<Datetime>>;
                    let _: ::core::clone::AssertParamIsClone<Option<Datetime>>;
                    let _: ::core::clone::AssertParamIsClone<Option<Datetime>>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for DescriptorStat {}
            impl ::core::fmt::Debug for DescriptorStat {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("DescriptorStat")
                        .field("type", &self.type_)
                        .field("link-count", &self.link_count)
                        .field("size", &self.size)
                        .field("data-access-timestamp", &self.data_access_timestamp)
                        .field(
                            "data-modification-timestamp",
                            &self.data_modification_timestamp,
                        )
                        .field("status-change-timestamp", &self.status_change_timestamp)
                        .finish()
                }
            }
            pub enum NewTimestamp {
                NoChange,
                Now,
                Timestamp(Datetime),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for NewTimestamp {
                #[inline]
                fn clone(&self) -> NewTimestamp {
                    let _: ::core::clone::AssertParamIsClone<Datetime>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NewTimestamp {}
            impl ::core::fmt::Debug for NewTimestamp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        NewTimestamp::NoChange => {
                            f.debug_tuple("NewTimestamp::NoChange").finish()
                        }
                        NewTimestamp::Now => f.debug_tuple("NewTimestamp::Now").finish(),
                        NewTimestamp::Timestamp(e) => {
                            f.debug_tuple("NewTimestamp::Timestamp").field(e).finish()
                        }
                    }
                }
            }
            pub struct DirectoryEntry {
                pub type_: DescriptorType,
                pub name: _rt::String,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for DirectoryEntry {
                #[inline]
                fn clone(&self) -> DirectoryEntry {
                    DirectoryEntry {
                        type_: ::core::clone::Clone::clone(&self.type_),
                        name: ::core::clone::Clone::clone(&self.name),
                    }
                }
            }
            impl ::core::fmt::Debug for DirectoryEntry {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("DirectoryEntry")
                        .field("type", &self.type_)
                        .field("name", &self.name)
                        .finish()
                }
            }
            #[repr(u8)]
            pub enum ErrorCode {
                Access,
                WouldBlock,
                Already,
                BadDescriptor,
                Busy,
                Deadlock,
                Quota,
                Exist,
                FileTooLarge,
                IllegalByteSequence,
                InProgress,
                Interrupted,
                Invalid,
                Io,
                IsDirectory,
                Loop,
                TooManyLinks,
                MessageSize,
                NameTooLong,
                NoDevice,
                NoEntry,
                NoLock,
                InsufficientMemory,
                InsufficientSpace,
                NotDirectory,
                NotEmpty,
                NotRecoverable,
                Unsupported,
                NoTty,
                NoSuchDevice,
                Overflow,
                NotPermitted,
                Pipe,
                ReadOnly,
                InvalidSeek,
                TextFileBusy,
                CrossDevice,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ErrorCode {
                #[inline]
                fn clone(&self) -> ErrorCode {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ErrorCode {}
            #[automatically_derived]
            impl ::core::cmp::Eq for ErrorCode {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for ErrorCode {
                #[inline]
                fn cmp(&self, other: &ErrorCode) -> ::core::cmp::Ordering {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ErrorCode {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ErrorCode {
                #[inline]
                fn eq(&self, other: &ErrorCode) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for ErrorCode {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &ErrorCode,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
                }
            }
            impl ErrorCode {
                pub fn name(&self) -> &'static str {
                    match self {
                        ErrorCode::Access => "access",
                        ErrorCode::WouldBlock => "would-block",
                        ErrorCode::Already => "already",
                        ErrorCode::BadDescriptor => "bad-descriptor",
                        ErrorCode::Busy => "busy",
                        ErrorCode::Deadlock => "deadlock",
                        ErrorCode::Quota => "quota",
                        ErrorCode::Exist => "exist",
                        ErrorCode::FileTooLarge => "file-too-large",
                        ErrorCode::IllegalByteSequence => "illegal-byte-sequence",
                        ErrorCode::InProgress => "in-progress",
                        ErrorCode::Interrupted => "interrupted",
                        ErrorCode::Invalid => "invalid",
                        ErrorCode::Io => "io",
                        ErrorCode::IsDirectory => "is-directory",
                        ErrorCode::Loop => "loop",
                        ErrorCode::TooManyLinks => "too-many-links",
                        ErrorCode::MessageSize => "message-size",
                        ErrorCode::NameTooLong => "name-too-long",
                        ErrorCode::NoDevice => "no-device",
                        ErrorCode::NoEntry => "no-entry",
                        ErrorCode::NoLock => "no-lock",
                        ErrorCode::InsufficientMemory => "insufficient-memory",
                        ErrorCode::InsufficientSpace => "insufficient-space",
                        ErrorCode::NotDirectory => "not-directory",
                        ErrorCode::NotEmpty => "not-empty",
                        ErrorCode::NotRecoverable => "not-recoverable",
                        ErrorCode::Unsupported => "unsupported",
                        ErrorCode::NoTty => "no-tty",
                        ErrorCode::NoSuchDevice => "no-such-device",
                        ErrorCode::Overflow => "overflow",
                        ErrorCode::NotPermitted => "not-permitted",
                        ErrorCode::Pipe => "pipe",
                        ErrorCode::ReadOnly => "read-only",
                        ErrorCode::InvalidSeek => "invalid-seek",
                        ErrorCode::TextFileBusy => "text-file-busy",
                        ErrorCode::CrossDevice => "cross-device",
                    }
                }
                pub fn message(&self) -> &'static str {
                    match self {
                        ErrorCode::Access => "",
                        ErrorCode::WouldBlock => "",
                        ErrorCode::Already => "",
                        ErrorCode::BadDescriptor => "",
                        ErrorCode::Busy => "",
                        ErrorCode::Deadlock => "",
                        ErrorCode::Quota => "",
                        ErrorCode::Exist => "",
                        ErrorCode::FileTooLarge => "",
                        ErrorCode::IllegalByteSequence => "",
                        ErrorCode::InProgress => "",
                        ErrorCode::Interrupted => "",
                        ErrorCode::Invalid => "",
                        ErrorCode::Io => "",
                        ErrorCode::IsDirectory => "",
                        ErrorCode::Loop => "",
                        ErrorCode::TooManyLinks => "",
                        ErrorCode::MessageSize => "",
                        ErrorCode::NameTooLong => "",
                        ErrorCode::NoDevice => "",
                        ErrorCode::NoEntry => "",
                        ErrorCode::NoLock => "",
                        ErrorCode::InsufficientMemory => "",
                        ErrorCode::InsufficientSpace => "",
                        ErrorCode::NotDirectory => "",
                        ErrorCode::NotEmpty => "",
                        ErrorCode::NotRecoverable => "",
                        ErrorCode::Unsupported => "",
                        ErrorCode::NoTty => "",
                        ErrorCode::NoSuchDevice => "",
                        ErrorCode::Overflow => "",
                        ErrorCode::NotPermitted => "",
                        ErrorCode::Pipe => "",
                        ErrorCode::ReadOnly => "",
                        ErrorCode::InvalidSeek => "",
                        ErrorCode::TextFileBusy => "",
                        ErrorCode::CrossDevice => "",
                    }
                }
            }
            impl ::core::fmt::Debug for ErrorCode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ErrorCode")
                        .field("code", &(*self as i32))
                        .field("name", &self.name())
                        .field("message", &self.message())
                        .finish()
                }
            }
            impl ::core::fmt::Display for ErrorCode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.write_fmt(
                        format_args!("{0} (error {1})", self.name(), *self as i32),
                    )
                }
            }
            impl ::core::error::Error for ErrorCode {}
            impl ErrorCode {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> ErrorCode {
                    if !true {
                        return unsafe { ::core::mem::transmute(val) };
                    }
                    match val {
                        0 => ErrorCode::Access,
                        1 => ErrorCode::WouldBlock,
                        2 => ErrorCode::Already,
                        3 => ErrorCode::BadDescriptor,
                        4 => ErrorCode::Busy,
                        5 => ErrorCode::Deadlock,
                        6 => ErrorCode::Quota,
                        7 => ErrorCode::Exist,
                        8 => ErrorCode::FileTooLarge,
                        9 => ErrorCode::IllegalByteSequence,
                        10 => ErrorCode::InProgress,
                        11 => ErrorCode::Interrupted,
                        12 => ErrorCode::Invalid,
                        13 => ErrorCode::Io,
                        14 => ErrorCode::IsDirectory,
                        15 => ErrorCode::Loop,
                        16 => ErrorCode::TooManyLinks,
                        17 => ErrorCode::MessageSize,
                        18 => ErrorCode::NameTooLong,
                        19 => ErrorCode::NoDevice,
                        20 => ErrorCode::NoEntry,
                        21 => ErrorCode::NoLock,
                        22 => ErrorCode::InsufficientMemory,
                        23 => ErrorCode::InsufficientSpace,
                        24 => ErrorCode::NotDirectory,
                        25 => ErrorCode::NotEmpty,
                        26 => ErrorCode::NotRecoverable,
                        27 => ErrorCode::Unsupported,
                        28 => ErrorCode::NoTty,
                        29 => ErrorCode::NoSuchDevice,
                        30 => ErrorCode::Overflow,
                        31 => ErrorCode::NotPermitted,
                        32 => ErrorCode::Pipe,
                        33 => ErrorCode::ReadOnly,
                        34 => ErrorCode::InvalidSeek,
                        35 => ErrorCode::TextFileBusy,
                        36 => ErrorCode::CrossDevice,
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("invalid enum discriminant"),
                            );
                        }
                    }
                }
            }
            #[repr(u8)]
            pub enum Advice {
                Normal,
                Sequential,
                Random,
                WillNeed,
                DontNeed,
                NoReuse,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Advice {
                #[inline]
                fn clone(&self) -> Advice {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Advice {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Advice {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Advice {
                #[inline]
                fn cmp(&self, other: &Advice) -> ::core::cmp::Ordering {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Advice {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Advice {
                #[inline]
                fn eq(&self, other: &Advice) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Advice {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Advice,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
                }
            }
            impl ::core::fmt::Debug for Advice {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Advice::Normal => f.debug_tuple("Advice::Normal").finish(),
                        Advice::Sequential => {
                            f.debug_tuple("Advice::Sequential").finish()
                        }
                        Advice::Random => f.debug_tuple("Advice::Random").finish(),
                        Advice::WillNeed => f.debug_tuple("Advice::WillNeed").finish(),
                        Advice::DontNeed => f.debug_tuple("Advice::DontNeed").finish(),
                        Advice::NoReuse => f.debug_tuple("Advice::NoReuse").finish(),
                    }
                }
            }
            impl Advice {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> Advice {
                    if !true {
                        return unsafe { ::core::mem::transmute(val) };
                    }
                    match val {
                        0 => Advice::Normal,
                        1 => Advice::Sequential,
                        2 => Advice::Random,
                        3 => Advice::WillNeed,
                        4 => Advice::DontNeed,
                        5 => Advice::NoReuse,
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("invalid enum discriminant"),
                            );
                        }
                    }
                }
            }
            #[repr(C)]
            pub struct MetadataHashValue {
                pub lower: u64,
                pub upper: u64,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for MetadataHashValue {
                #[inline]
                fn clone(&self) -> MetadataHashValue {
                    let _: ::core::clone::AssertParamIsClone<u64>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for MetadataHashValue {}
            impl ::core::fmt::Debug for MetadataHashValue {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("MetadataHashValue")
                        .field("lower", &self.lower)
                        .field("upper", &self.upper)
                        .finish()
                }
            }
            #[repr(transparent)]
            pub struct Descriptor {
                handle: _rt::Resource<Descriptor>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Descriptor {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Descriptor",
                        "handle",
                        &&self.handle,
                    )
                }
            }
            impl Descriptor {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for Descriptor {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    unsafe extern "C" fn drop(_: i32) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    unsafe {
                        drop(_handle as i32);
                    }
                }
            }
            #[repr(transparent)]
            pub struct DirectoryEntryStream {
                handle: _rt::Resource<DirectoryEntryStream>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for DirectoryEntryStream {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "DirectoryEntryStream",
                        "handle",
                        &&self.handle,
                    )
                }
            }
            impl DirectoryEntryStream {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for DirectoryEntryStream {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    unsafe extern "C" fn drop(_: i32) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    unsafe {
                        drop(_handle as i32);
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn read_via_stream(
                    &self,
                    offset: Filesize,
                ) -> Result<InputStream, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(offset), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    super::super::super::wasi::io::streams::InputStream::from_handle(
                                        l3 as u32,
                                    )
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn write_via_stream(
                    &self,
                    offset: Filesize,
                ) -> Result<OutputStream, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(offset), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    super::super::super::wasi::io::streams::OutputStream::from_handle(
                                        l3 as u32,
                                    )
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn append_via_stream(&self) -> Result<OutputStream, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    super::super::super::wasi::io::streams::OutputStream::from_handle(
                                        l3 as u32,
                                    )
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn advise(
                    &self,
                    offset: Filesize,
                    length: Filesize,
                    advice: Advice,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(
                            _: i32,
                            _: i64,
                            _: i64,
                            _: i32,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1(
                            (self).handle() as i32,
                            _rt::as_i64(offset),
                            _rt::as_i64(length),
                            advice.clone() as i32,
                            ptr0,
                        );
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn sync_data(&self) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn get_flags(&self) -> Result<DescriptorFlags, ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    DescriptorFlags::empty()
                                        | DescriptorFlags::from_bits_retain(((l3 as u8) << 0) as _)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn get_type(&self) -> Result<DescriptorType, ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    DescriptorType::_lift(l3 as u8)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_size(&self, size: Filesize) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(size), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_times(
                    &self,
                    data_access_timestamp: NewTimestamp,
                    data_modification_timestamp: NewTimestamp,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let (result1_0, result1_1, result1_2) = match data_access_timestamp {
                            NewTimestamp::NoChange => (0i32, 0i64, 0i32),
                            NewTimestamp::Now => (1i32, 0i64, 0i32),
                            NewTimestamp::Timestamp(e) => {
                                let super::super::super::wasi::clocks::wall_clock::Datetime {
                                    seconds: seconds0,
                                    nanoseconds: nanoseconds0,
                                } = e;
                                (2i32, _rt::as_i64(seconds0), _rt::as_i32(nanoseconds0))
                            }
                        };
                        let (result3_0, result3_1, result3_2) = match data_modification_timestamp {
                            NewTimestamp::NoChange => (0i32, 0i64, 0i32),
                            NewTimestamp::Now => (1i32, 0i64, 0i32),
                            NewTimestamp::Timestamp(e) => {
                                let super::super::super::wasi::clocks::wall_clock::Datetime {
                                    seconds: seconds2,
                                    nanoseconds: nanoseconds2,
                                } = e;
                                (2i32, _rt::as_i64(seconds2), _rt::as_i32(nanoseconds2))
                            }
                        };
                        let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import5(
                            _: i32,
                            _: i32,
                            _: i64,
                            _: i32,
                            _: i32,
                            _: i64,
                            _: i32,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import5(
                            (self).handle() as i32,
                            result1_0,
                            result1_1,
                            result1_2,
                            result3_0,
                            result3_1,
                            result3_2,
                            ptr4,
                        );
                        let l6 = i32::from(*ptr4.add(0).cast::<u8>());
                        let result8 = match l6 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l7 = i32::from(*ptr4.add(1).cast::<u8>());
                                    ErrorCode::_lift(l7 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result8
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn read(
                    &self,
                    length: Filesize,
                    offset: Filesize,
                ) -> Result<(_rt::Vec<u8>, bool), ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 4
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(
                            _: i32,
                            _: i64,
                            _: i64,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1(
                            (self).handle() as i32,
                            _rt::as_i64(length),
                            _rt::as_i64(offset),
                            ptr0,
                        );
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result8 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l4 = *ptr0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len5 = l4;
                                    let l6 = i32::from(
                                        *ptr0
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    (
                                        _rt::Vec::from_raw_parts(l3.cast(), len5, len5),
                                        _rt::bool_lift(l6 as u8),
                                    )
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l7 = i32::from(
                                        *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    ErrorCode::_lift(l7 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result8
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn write(
                    &self,
                    buffer: &[u8],
                    offset: Filesize,
                ) -> Result<Filesize, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let vec0 = buffer;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: i64,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2(
                            (self).handle() as i32,
                            ptr0.cast_mut(),
                            len0,
                            _rt::as_i64(offset),
                            ptr1,
                        );
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result6 = match l3 {
                            0 => {
                                let e = {
                                    let l4 = *ptr1.add(8).cast::<i64>();
                                    l4 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = i32::from(*ptr1.add(8).cast::<u8>());
                                    ErrorCode::_lift(l5 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn read_directory(&self) -> Result<DirectoryEntryStream, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    DirectoryEntryStream::from_handle(l3 as u32)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn sync(&self) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn create_directory_at(&self, path: &str) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let vec0 = path;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result5 = match l3 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr1.add(1).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn stat(&self) -> Result<DescriptorStat, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 104]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 104],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result16 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(8).cast::<u8>());
                                    let l4 = *ptr0.add(16).cast::<i64>();
                                    let l5 = *ptr0.add(24).cast::<i64>();
                                    let l6 = i32::from(*ptr0.add(32).cast::<u8>());
                                    let l9 = i32::from(*ptr0.add(56).cast::<u8>());
                                    let l12 = i32::from(*ptr0.add(80).cast::<u8>());
                                    DescriptorStat {
                                        type_: DescriptorType::_lift(l3 as u8),
                                        link_count: l4 as u64,
                                        size: l5 as u64,
                                        data_access_timestamp: match l6 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l7 = *ptr0.add(40).cast::<i64>();
                                                    let l8 = *ptr0.add(48).cast::<i32>();
                                                    super::super::super::wasi::clocks::wall_clock::Datetime {
                                                        seconds: l7 as u64,
                                                        nanoseconds: l8 as u32,
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        data_modification_timestamp: match l9 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l10 = *ptr0.add(64).cast::<i64>();
                                                    let l11 = *ptr0.add(72).cast::<i32>();
                                                    super::super::super::wasi::clocks::wall_clock::Datetime {
                                                        seconds: l10 as u64,
                                                        nanoseconds: l11 as u32,
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        status_change_timestamp: match l12 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l13 = *ptr0.add(88).cast::<i64>();
                                                    let l14 = *ptr0.add(96).cast::<i32>();
                                                    super::super::super::wasi::clocks::wall_clock::Datetime {
                                                        seconds: l13 as u64,
                                                        nanoseconds: l14 as u32,
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l15 = i32::from(*ptr0.add(8).cast::<u8>());
                                    ErrorCode::_lift(l15 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result16
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn stat_at(
                    &self,
                    path_flags: PathFlags,
                    path: &str,
                ) -> Result<DescriptorStat, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 104]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 104],
                        );
                        let flags0 = path_flags;
                        let vec1 = path;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import3(
                            _: i32,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import3(
                            (self).handle() as i32,
                            (flags0.bits() >> 0) as i32,
                            ptr1.cast_mut(),
                            len1,
                            ptr2,
                        );
                        let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                        let result18 = match l4 {
                            0 => {
                                let e = {
                                    let l5 = i32::from(*ptr2.add(8).cast::<u8>());
                                    let l6 = *ptr2.add(16).cast::<i64>();
                                    let l7 = *ptr2.add(24).cast::<i64>();
                                    let l8 = i32::from(*ptr2.add(32).cast::<u8>());
                                    let l11 = i32::from(*ptr2.add(56).cast::<u8>());
                                    let l14 = i32::from(*ptr2.add(80).cast::<u8>());
                                    DescriptorStat {
                                        type_: DescriptorType::_lift(l5 as u8),
                                        link_count: l6 as u64,
                                        size: l7 as u64,
                                        data_access_timestamp: match l8 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l9 = *ptr2.add(40).cast::<i64>();
                                                    let l10 = *ptr2.add(48).cast::<i32>();
                                                    super::super::super::wasi::clocks::wall_clock::Datetime {
                                                        seconds: l9 as u64,
                                                        nanoseconds: l10 as u32,
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        data_modification_timestamp: match l11 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l12 = *ptr2.add(64).cast::<i64>();
                                                    let l13 = *ptr2.add(72).cast::<i32>();
                                                    super::super::super::wasi::clocks::wall_clock::Datetime {
                                                        seconds: l12 as u64,
                                                        nanoseconds: l13 as u32,
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        status_change_timestamp: match l14 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l15 = *ptr2.add(88).cast::<i64>();
                                                    let l16 = *ptr2.add(96).cast::<i32>();
                                                    super::super::super::wasi::clocks::wall_clock::Datetime {
                                                        seconds: l15 as u64,
                                                        nanoseconds: l16 as u32,
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l17 = i32::from(*ptr2.add(8).cast::<u8>());
                                    ErrorCode::_lift(l17 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result18
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_times_at(
                    &self,
                    path_flags: PathFlags,
                    path: &str,
                    data_access_timestamp: NewTimestamp,
                    data_modification_timestamp: NewTimestamp,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let flags0 = path_flags;
                        let vec1 = path;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        let (result3_0, result3_1, result3_2) = match data_access_timestamp {
                            NewTimestamp::NoChange => (0i32, 0i64, 0i32),
                            NewTimestamp::Now => (1i32, 0i64, 0i32),
                            NewTimestamp::Timestamp(e) => {
                                let super::super::super::wasi::clocks::wall_clock::Datetime {
                                    seconds: seconds2,
                                    nanoseconds: nanoseconds2,
                                } = e;
                                (2i32, _rt::as_i64(seconds2), _rt::as_i32(nanoseconds2))
                            }
                        };
                        let (result5_0, result5_1, result5_2) = match data_modification_timestamp {
                            NewTimestamp::NoChange => (0i32, 0i64, 0i32),
                            NewTimestamp::Now => (1i32, 0i64, 0i32),
                            NewTimestamp::Timestamp(e) => {
                                let super::super::super::wasi::clocks::wall_clock::Datetime {
                                    seconds: seconds4,
                                    nanoseconds: nanoseconds4,
                                } = e;
                                (2i32, _rt::as_i64(seconds4), _rt::as_i32(nanoseconds4))
                            }
                        };
                        let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import7(
                            _: i32,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: i64,
                            _: i32,
                            _: i32,
                            _: i64,
                            _: i32,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import7(
                            (self).handle() as i32,
                            (flags0.bits() >> 0) as i32,
                            ptr1.cast_mut(),
                            len1,
                            result3_0,
                            result3_1,
                            result3_2,
                            result5_0,
                            result5_1,
                            result5_2,
                            ptr6,
                        );
                        let l8 = i32::from(*ptr6.add(0).cast::<u8>());
                        let result10 = match l8 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l9 = i32::from(*ptr6.add(1).cast::<u8>());
                                    ErrorCode::_lift(l9 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result10
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn link_at(
                    &self,
                    old_path_flags: PathFlags,
                    old_path: &str,
                    new_descriptor: &Descriptor,
                    new_path: &str,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let flags0 = old_path_flags;
                        let vec1 = old_path;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        let vec2 = new_path;
                        let ptr2 = vec2.as_ptr().cast::<u8>();
                        let len2 = vec2.len();
                        let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import4(
                            _: i32,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import4(
                            (self).handle() as i32,
                            (flags0.bits() >> 0) as i32,
                            ptr1.cast_mut(),
                            len1,
                            (new_descriptor).handle() as i32,
                            ptr2.cast_mut(),
                            len2,
                            ptr3,
                        );
                        let l5 = i32::from(*ptr3.add(0).cast::<u8>());
                        let result7 = match l5 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l6 = i32::from(*ptr3.add(1).cast::<u8>());
                                    ErrorCode::_lift(l6 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result7
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn open_at(
                    &self,
                    path_flags: PathFlags,
                    path: &str,
                    open_flags: OpenFlags,
                    flags: DescriptorFlags,
                ) -> Result<Descriptor, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let flags0 = path_flags;
                        let vec1 = path;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        let flags2 = open_flags;
                        let flags3 = flags;
                        let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import5(
                            _: i32,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: i32,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import5(
                            (self).handle() as i32,
                            (flags0.bits() >> 0) as i32,
                            ptr1.cast_mut(),
                            len1,
                            (flags2.bits() >> 0) as i32,
                            (flags3.bits() >> 0) as i32,
                            ptr4,
                        );
                        let l6 = i32::from(*ptr4.add(0).cast::<u8>());
                        let result9 = match l6 {
                            0 => {
                                let e = {
                                    let l7 = *ptr4.add(4).cast::<i32>();
                                    Descriptor::from_handle(l7 as u32)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l8 = i32::from(*ptr4.add(4).cast::<u8>());
                                    ErrorCode::_lift(l8 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result9
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn readlink_at(&self, path: &str) -> Result<_rt::String, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = path;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result8 = match l3 {
                            0 => {
                                let e = {
                                    let l4 = *ptr1
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l5 = *ptr1
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len6 = l5;
                                    let bytes6 = _rt::Vec::from_raw_parts(
                                        l4.cast(),
                                        len6,
                                        len6,
                                    );
                                    _rt::string_lift(bytes6)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l7 = i32::from(
                                        *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    ErrorCode::_lift(l7 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result8
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn remove_directory_at(&self, path: &str) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let vec0 = path;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result5 = match l3 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr1.add(1).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn rename_at(
                    &self,
                    old_path: &str,
                    new_descriptor: &Descriptor,
                    new_path: &str,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let vec0 = old_path;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let vec1 = new_path;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import3(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import3(
                            (self).handle() as i32,
                            ptr0.cast_mut(),
                            len0,
                            (new_descriptor).handle() as i32,
                            ptr1.cast_mut(),
                            len1,
                            ptr2,
                        );
                        let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                        let result6 = match l4 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = i32::from(*ptr2.add(1).cast::<u8>());
                                    ErrorCode::_lift(l5 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn symlink_at(
                    &self,
                    old_path: &str,
                    new_path: &str,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let vec0 = old_path;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let vec1 = new_path;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import3(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import3(
                            (self).handle() as i32,
                            ptr0.cast_mut(),
                            len0,
                            ptr1.cast_mut(),
                            len1,
                            ptr2,
                        );
                        let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                        let result6 = match l4 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = i32::from(*ptr2.add(1).cast::<u8>());
                                    ErrorCode::_lift(l5 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn unlink_file_at(&self, path: &str) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let vec0 = path;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result5 = match l3 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr1.add(1).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn is_same_object(&self, other: &Descriptor) -> bool {
                    unsafe {
                        unsafe extern "C" fn wit_import0(_: i32, _: i32) -> i32 {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        let ret = wit_import0(
                            (self).handle() as i32,
                            (other).handle() as i32,
                        );
                        _rt::bool_lift(ret as u8)
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn metadata_hash(&self) -> Result<MetadataHashValue, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 24]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 24],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result6 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    let l4 = *ptr0.add(16).cast::<i64>();
                                    MetadataHashValue {
                                        lower: l3 as u64,
                                        upper: l4 as u64,
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = i32::from(*ptr0.add(8).cast::<u8>());
                                    ErrorCode::_lift(l5 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn metadata_hash_at(
                    &self,
                    path_flags: PathFlags,
                    path: &str,
                ) -> Result<MetadataHashValue, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 24]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 24],
                        );
                        let flags0 = path_flags;
                        let vec1 = path;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import3(
                            _: i32,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import3(
                            (self).handle() as i32,
                            (flags0.bits() >> 0) as i32,
                            ptr1.cast_mut(),
                            len1,
                            ptr2,
                        );
                        let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                        let result8 = match l4 {
                            0 => {
                                let e = {
                                    let l5 = *ptr2.add(8).cast::<i64>();
                                    let l6 = *ptr2.add(16).cast::<i64>();
                                    MetadataHashValue {
                                        lower: l5 as u64,
                                        upper: l6 as u64,
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l7 = i32::from(*ptr2.add(8).cast::<u8>());
                                    ErrorCode::_lift(l7 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result8
                    }
                }
            }
            impl DirectoryEntryStream {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn read_directory_entry(
                    &self,
                ) -> Result<Option<DirectoryEntry>, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 5 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 5
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result9 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(
                                        *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    match l3 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l4 = i32::from(
                                                    *ptr0
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                let l5 = *ptr0
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l6 = *ptr0
                                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len7 = l6;
                                                let bytes7 = _rt::Vec::from_raw_parts(
                                                    l5.cast(),
                                                    len7,
                                                    len7,
                                                );
                                                DirectoryEntry {
                                                    type_: DescriptorType::_lift(l4 as u8),
                                                    name: _rt::string_lift(bytes7),
                                                }
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l8 = i32::from(
                                        *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    ErrorCode::_lift(l8 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result9
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn filesystem_error_code(err: &Error) -> Option<ErrorCode> {
                unsafe {
                    #[repr(align(1))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import1((err).handle() as i32, ptr0);
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result4 = match l2 {
                        0 => None,
                        1 => {
                            let e = {
                                let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                ErrorCode::_lift(l3 as u8)
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result4
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod preopens {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Descriptor = super::super::super::wasi::filesystem::types::Descriptor;
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn get_directories() -> _rt::Vec<(Descriptor, _rt::String)> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import1(ptr0);
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base8 = l2;
                    let len8 = l3;
                    let mut result8 = _rt::Vec::with_capacity(len8);
                    for i in 0..len8 {
                        let base = base8
                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                        let e8 = {
                            let l4 = *base.add(0).cast::<i32>();
                            let l5 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l6 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len7 = l6;
                            let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                            (
                                super::super::super::wasi::filesystem::types::Descriptor::from_handle(
                                    l4 as u32,
                                ),
                                _rt::string_lift(bytes7),
                            )
                        };
                        result8.push(e8);
                    }
                    _rt::cabi_dealloc(
                        base8,
                        len8 * (3 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result9 = result8;
                    result9
                }
            }
        }
    }
    pub mod io {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod error {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            /// A resource which represents some error information.
            ///
            /// The only method provided by this resource is `to-debug-string`,
            /// which provides some human-readable information about the error.
            ///
            /// In the `wasi:io` package, this resource is returned through the
            /// `wasi:io/streams/stream-error` type.
            ///
            /// To provide more specific error information, other interfaces may
            /// provide functions to further "downcast" this error into more specific
            /// error information. For example, `error`s returned in streams derived
            /// from filesystem types to be described using the filesystem's own
            /// error-code type, using the function
            /// `wasi:filesystem/types/filesystem-error-code`, which takes a parameter
            /// `borrow<error>` and returns
            /// `option<wasi:filesystem/types/error-code>`.
            ///
            /// The set of functions which can "downcast" an `error` into a more
            /// concrete type is open.
            #[repr(transparent)]
            pub struct Error {
                handle: _rt::Resource<Error>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Error {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Error",
                        "handle",
                        &&self.handle,
                    )
                }
            }
            impl Error {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for Error {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    unsafe extern "C" fn drop(_: i32) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    unsafe {
                        drop(_handle as i32);
                    }
                }
            }
            impl Error {
                #[allow(unused_unsafe, clippy::all)]
                /// Returns a string that is suitable to assist humans in debugging
                /// this error.
                ///
                /// WARNING: The returned string should not be consumed mechanically!
                /// It may change across platforms, hosts, or other implementation
                /// details. Parsing this string is a major platform-compatibility
                /// hazard.
                #[allow(async_fn_in_trait)]
                pub fn to_debug_string(&self) -> _rt::String {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 2 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = *ptr0.add(0).cast::<*mut u8>();
                        let l3 = *ptr0
                            .add(::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let len4 = l3;
                        let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                        let result5 = _rt::string_lift(bytes4);
                        result5
                    }
                }
            }
        }
        /// A poll API intended to let users wait for I/O events on multiple handles
        /// at once.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod poll {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            /// `pollable` represents a single I/O event which may be ready, or not.
            #[repr(transparent)]
            pub struct Pollable {
                handle: _rt::Resource<Pollable>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Pollable {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Pollable",
                        "handle",
                        &&self.handle,
                    )
                }
            }
            impl Pollable {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for Pollable {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    unsafe extern "C" fn drop(_: i32) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    unsafe {
                        drop(_handle as i32);
                    }
                }
            }
            impl Pollable {
                #[allow(unused_unsafe, clippy::all)]
                /// Return the readiness of a pollable. This function never blocks.
                ///
                /// Returns `true` when the pollable is ready, and `false` otherwise.
                #[allow(async_fn_in_trait)]
                pub fn ready(&self) -> bool {
                    unsafe {
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        let ret = wit_import0((self).handle() as i32);
                        _rt::bool_lift(ret as u8)
                    }
                }
            }
            impl Pollable {
                #[allow(unused_unsafe, clippy::all)]
                /// `block` returns immediately if the pollable is ready, and otherwise
                /// blocks until ready.
                ///
                /// This function is equivalent to calling `poll.poll` on a list
                /// containing only this pollable.
                #[allow(async_fn_in_trait)]
                pub fn block(&self) -> () {
                    unsafe {
                        unsafe extern "C" fn wit_import0(_: i32) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import0((self).handle() as i32);
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Poll for completion on a set of pollables.
            ///
            /// This function takes a list of pollables, which identify I/O sources of
            /// interest, and waits until one or more of the events is ready for I/O.
            ///
            /// The result `list<u32>` contains one or more indices of handles in the
            /// argument list that is ready for I/O.
            ///
            /// If the list contains more elements than can be indexed with a `u32`
            /// value, this function traps.
            ///
            /// A timeout can be implemented by adding a pollable from the
            /// wasi-clocks API to the list.
            ///
            /// This function does not return a `result`; polling in itself does not
            /// do any I/O so it doesn't fail. If any of the I/O sources identified by
            /// the pollables has an error, it is indicated by marking the source as
            /// being reaedy for I/O.
            #[allow(async_fn_in_trait)]
            pub fn poll(in_: &[&Pollable]) -> _rt::Vec<u32> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = in_;
                    let len0 = vec0.len();
                    let layout0 = _rt::alloc::Layout::from_size_align(vec0.len() * 4, 4)
                        .unwrap();
                    let (result0, _cleanup0) = wit_bindgen::rt::Cleanup::new(layout0);
                    for (i, e) in vec0.into_iter().enumerate() {
                        let base = result0.add(i * 4);
                        {
                            *base.add(0).cast::<i32>() = (e).handle() as i32;
                        }
                    }
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import2(result0, len0, ptr1);
                    let l3 = *ptr1.add(0).cast::<*mut u8>();
                    let l4 = *ptr1
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len5 = l4;
                    let result6 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                    result6
                }
            }
        }
        /// WASI I/O is an I/O abstraction API which is currently focused on providing
        /// stream types.
        ///
        /// In the future, the component model is expected to add built-in stream types;
        /// when it does, they are expected to subsume this API.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod streams {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Error = super::super::super::wasi::io::error::Error;
            pub type Pollable = super::super::super::wasi::io::poll::Pollable;
            /// An error for input-stream and output-stream operations.
            pub enum StreamError {
                /// The last operation (a write or flush) failed before completion.
                ///
                /// More information is available in the `error` payload.
                LastOperationFailed(Error),
                /// The stream is closed: no more input will be accepted by the
                /// stream. A closed output-stream will return this error on all
                /// future operations.
                Closed,
            }
            impl ::core::fmt::Debug for StreamError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        StreamError::LastOperationFailed(e) => {
                            f.debug_tuple("StreamError::LastOperationFailed")
                                .field(e)
                                .finish()
                        }
                        StreamError::Closed => {
                            f.debug_tuple("StreamError::Closed").finish()
                        }
                    }
                }
            }
            impl ::core::fmt::Display for StreamError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.write_fmt(format_args!("{0:?}", self))
                }
            }
            impl ::core::error::Error for StreamError {}
            /// An input bytestream.
            ///
            /// `input-stream`s are *non-blocking* to the extent practical on underlying
            /// platforms. I/O operations always return promptly; if fewer bytes are
            /// promptly available than requested, they return the number of bytes promptly
            /// available, which could even be zero. To wait for data to be available,
            /// use the `subscribe` function to obtain a `pollable` which can be polled
            /// for using `wasi:io/poll`.
            #[repr(transparent)]
            pub struct InputStream {
                handle: _rt::Resource<InputStream>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for InputStream {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "InputStream",
                        "handle",
                        &&self.handle,
                    )
                }
            }
            impl InputStream {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for InputStream {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    unsafe extern "C" fn drop(_: i32) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    unsafe {
                        drop(_handle as i32);
                    }
                }
            }
            /// An output bytestream.
            ///
            /// `output-stream`s are *non-blocking* to the extent practical on
            /// underlying platforms. Except where specified otherwise, I/O operations also
            /// always return promptly, after the number of bytes that can be written
            /// promptly, which could even be zero. To wait for the stream to be ready to
            /// accept data, the `subscribe` function to obtain a `pollable` which can be
            /// polled for using `wasi:io/poll`.
            #[repr(transparent)]
            pub struct OutputStream {
                handle: _rt::Resource<OutputStream>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for OutputStream {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "OutputStream",
                        "handle",
                        &&self.handle,
                    )
                }
            }
            impl OutputStream {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for OutputStream {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    unsafe extern "C" fn drop(_: i32) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    unsafe {
                        drop(_handle as i32);
                    }
                }
            }
            impl InputStream {
                #[allow(unused_unsafe, clippy::all)]
                /// Perform a non-blocking read from the stream.
                ///
                /// When the source of a `read` is binary data, the bytes from the source
                /// are returned verbatim. When the source of a `read` is known to the
                /// implementation to be text, bytes containing the UTF-8 encoding of the
                /// text are returned.
                ///
                /// This function returns a list of bytes containing the read data,
                /// when successful. The returned list will contain up to `len` bytes;
                /// it may return fewer than requested, but not more. The list is
                /// empty when no bytes are available for reading at this time. The
                /// pollable given by `subscribe` will be ready when more bytes are
                /// available.
                ///
                /// This function fails with a `stream-error` when the operation
                /// encounters an error, giving `last-operation-failed`, or when the
                /// stream is closed, giving `closed`.
                ///
                /// When the caller gives a `len` of 0, it represents a request to
                /// read 0 bytes. If the stream is still open, this call should
                /// succeed and return an empty list, or otherwise fail with `closed`.
                ///
                /// The `len` parameter is a `u64`, which could represent a list of u8 which
                /// is not possible to allocate in wasm32, or not desirable to allocate as
                /// as a return value by the callee. The callee may return a list of bytes
                /// less than `len` in size while more bytes are available for reading.
                #[allow(async_fn_in_trait)]
                pub fn read(&self, len: u64) -> Result<_rt::Vec<u8>, StreamError> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(&len), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result9 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l4 = *ptr0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len5 = l4;
                                    _rt::Vec::from_raw_parts(l3.cast(), len5, len5)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l6 = i32::from(
                                        *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    let v8 = match l6 {
                                        0 => {
                                            let e8 = {
                                                let l7 = *ptr0
                                                    .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i32>();
                                                super::super::super::wasi::io::error::Error::from_handle(
                                                    l7 as u32,
                                                )
                                            };
                                            StreamError::LastOperationFailed(e8)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &1) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            StreamError::Closed
                                        }
                                    };
                                    v8
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result9
                    }
                }
            }
            impl InputStream {
                #[allow(unused_unsafe, clippy::all)]
                /// Read bytes from a stream, after blocking until at least one byte can
                /// be read. Except for blocking, behavior is identical to `read`.
                #[allow(async_fn_in_trait)]
                pub fn blocking_read(
                    &self,
                    len: u64,
                ) -> Result<_rt::Vec<u8>, StreamError> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(&len), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result9 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l4 = *ptr0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len5 = l4;
                                    _rt::Vec::from_raw_parts(l3.cast(), len5, len5)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l6 = i32::from(
                                        *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    let v8 = match l6 {
                                        0 => {
                                            let e8 = {
                                                let l7 = *ptr0
                                                    .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i32>();
                                                super::super::super::wasi::io::error::Error::from_handle(
                                                    l7 as u32,
                                                )
                                            };
                                            StreamError::LastOperationFailed(e8)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &1) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            StreamError::Closed
                                        }
                                    };
                                    v8
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result9
                    }
                }
            }
            impl InputStream {
                #[allow(unused_unsafe, clippy::all)]
                /// Skip bytes from a stream. Returns number of bytes skipped.
                ///
                /// Behaves identical to `read`, except instead of returning a list
                /// of bytes, returns the number of bytes consumed from the stream.
                #[allow(async_fn_in_trait)]
                pub fn skip(&self, len: u64) -> Result<u64, StreamError> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(&len), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result7 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    let v6 = match l4 {
                                        0 => {
                                            let e6 = {
                                                let l5 = *ptr0.add(12).cast::<i32>();
                                                super::super::super::wasi::io::error::Error::from_handle(
                                                    l5 as u32,
                                                )
                                            };
                                            StreamError::LastOperationFailed(e6)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &1) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            StreamError::Closed
                                        }
                                    };
                                    v6
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result7
                    }
                }
            }
            impl InputStream {
                #[allow(unused_unsafe, clippy::all)]
                /// Skip bytes from a stream, after blocking until at least one byte
                /// can be skipped. Except for blocking behavior, identical to `skip`.
                #[allow(async_fn_in_trait)]
                pub fn blocking_skip(&self, len: u64) -> Result<u64, StreamError> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(&len), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result7 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    let v6 = match l4 {
                                        0 => {
                                            let e6 = {
                                                let l5 = *ptr0.add(12).cast::<i32>();
                                                super::super::super::wasi::io::error::Error::from_handle(
                                                    l5 as u32,
                                                )
                                            };
                                            StreamError::LastOperationFailed(e6)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &1) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            StreamError::Closed
                                        }
                                    };
                                    v6
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result7
                    }
                }
            }
            impl InputStream {
                #[allow(unused_unsafe, clippy::all)]
                /// Create a `pollable` which will resolve once either the specified stream
                /// has bytes available to read or the other end of the stream has been
                /// closed.
                /// The created `pollable` is a child resource of the `input-stream`.
                /// Implementations may trap if the `input-stream` is dropped before
                /// all derived `pollable`s created with this function are dropped.
                #[allow(async_fn_in_trait)]
                pub fn subscribe(&self) -> Pollable {
                    unsafe {
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        let ret = wit_import0((self).handle() as i32);
                        super::super::super::wasi::io::poll::Pollable::from_handle(
                            ret as u32,
                        )
                    }
                }
            }
            impl OutputStream {
                #[allow(unused_unsafe, clippy::all)]
                /// Check readiness for writing. This function never blocks.
                ///
                /// Returns the number of bytes permitted for the next call to `write`,
                /// or an error. Calling `write` with more bytes than this function has
                /// permitted will trap.
                ///
                /// When this function returns 0 bytes, the `subscribe` pollable will
                /// become ready when this function will report at least 1 byte, or an
                /// error.
                #[allow(async_fn_in_trait)]
                pub fn check_write(&self) -> Result<u64, StreamError> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result7 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    let v6 = match l4 {
                                        0 => {
                                            let e6 = {
                                                let l5 = *ptr0.add(12).cast::<i32>();
                                                super::super::super::wasi::io::error::Error::from_handle(
                                                    l5 as u32,
                                                )
                                            };
                                            StreamError::LastOperationFailed(e6)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &1) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            StreamError::Closed
                                        }
                                    };
                                    v6
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result7
                    }
                }
            }
            impl OutputStream {
                #[allow(unused_unsafe, clippy::all)]
                /// Perform a write. This function never blocks.
                ///
                /// When the destination of a `write` is binary data, the bytes from
                /// `contents` are written verbatim. When the destination of a `write` is
                /// known to the implementation to be text, the bytes of `contents` are
                /// transcoded from UTF-8 into the encoding of the destination and then
                /// written.
                ///
                /// Precondition: check-write gave permit of Ok(n) and contents has a
                /// length of less than or equal to n. Otherwise, this function will trap.
                ///
                /// returns Err(closed) without writing if the stream has closed since
                /// the last call to check-write provided a permit.
                #[allow(async_fn_in_trait)]
                pub fn write(&self, contents: &[u8]) -> Result<(), StreamError> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 12],
                        );
                        let vec0 = contents;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result7 = match l3 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr1.add(4).cast::<u8>());
                                    let v6 = match l4 {
                                        0 => {
                                            let e6 = {
                                                let l5 = *ptr1.add(8).cast::<i32>();
                                                super::super::super::wasi::io::error::Error::from_handle(
                                                    l5 as u32,
                                                )
                                            };
                                            StreamError::LastOperationFailed(e6)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &1) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            StreamError::Closed
                                        }
                                    };
                                    v6
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result7
                    }
                }
            }
            impl OutputStream {
                #[allow(unused_unsafe, clippy::all)]
                /// Perform a write of up to 4096 bytes, and then flush the stream. Block
                /// until all of these operations are complete, or an error occurs.
                ///
                /// This is a convenience wrapper around the use of `check-write`,
                /// `subscribe`, `write`, and `flush`, and is implemented with the
                /// following pseudo-code:
                ///
                /// ```text
                /// let pollable = this.subscribe();
                /// while !contents.is_empty() {
                /// // Wait for the stream to become writable
                /// pollable.block();
                /// let Ok(n) = this.check-write(); // eliding error handling
                /// let len = min(n, contents.len());
                /// let (chunk, rest) = contents.split_at(len);
                /// this.write(chunk  );            // eliding error handling
                /// contents = rest;
                /// }
                /// this.flush();
                /// // Wait for completion of `flush`
                /// pollable.block();
                /// // Check for any errors that arose during `flush`
                /// let _ = this.check-write();         // eliding error handling
                /// ```
                #[allow(async_fn_in_trait)]
                pub fn blocking_write_and_flush(
                    &self,
                    contents: &[u8],
                ) -> Result<(), StreamError> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 12],
                        );
                        let vec0 = contents;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result7 = match l3 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr1.add(4).cast::<u8>());
                                    let v6 = match l4 {
                                        0 => {
                                            let e6 = {
                                                let l5 = *ptr1.add(8).cast::<i32>();
                                                super::super::super::wasi::io::error::Error::from_handle(
                                                    l5 as u32,
                                                )
                                            };
                                            StreamError::LastOperationFailed(e6)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &1) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            StreamError::Closed
                                        }
                                    };
                                    v6
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result7
                    }
                }
            }
            impl OutputStream {
                #[allow(unused_unsafe, clippy::all)]
                /// Request to flush buffered output. This function never blocks.
                ///
                /// This tells the output-stream that the caller intends any buffered
                /// output to be flushed. the output which is expected to be flushed
                /// is all that has been passed to `write` prior to this call.
                ///
                /// Upon calling this function, the `output-stream` will not accept any
                /// writes (`check-write` will return `ok(0)`) until the flush has
                /// completed. The `subscribe` pollable will become ready when the
                /// flush has completed and the stream can accept more writes.
                #[allow(async_fn_in_trait)]
                pub fn flush(&self) -> Result<(), StreamError> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 12],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result6 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                    let v5 = match l3 {
                                        0 => {
                                            let e5 = {
                                                let l4 = *ptr0.add(8).cast::<i32>();
                                                super::super::super::wasi::io::error::Error::from_handle(
                                                    l4 as u32,
                                                )
                                            };
                                            StreamError::LastOperationFailed(e5)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &1) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            StreamError::Closed
                                        }
                                    };
                                    v5
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl OutputStream {
                #[allow(unused_unsafe, clippy::all)]
                /// Request to flush buffered output, and block until flush completes
                /// and stream is ready for writing again.
                #[allow(async_fn_in_trait)]
                pub fn blocking_flush(&self) -> Result<(), StreamError> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 12],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result6 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                    let v5 = match l3 {
                                        0 => {
                                            let e5 = {
                                                let l4 = *ptr0.add(8).cast::<i32>();
                                                super::super::super::wasi::io::error::Error::from_handle(
                                                    l4 as u32,
                                                )
                                            };
                                            StreamError::LastOperationFailed(e5)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &1) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            StreamError::Closed
                                        }
                                    };
                                    v5
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl OutputStream {
                #[allow(unused_unsafe, clippy::all)]
                /// Create a `pollable` which will resolve once the output-stream
                /// is ready for more writing, or an error has occured. When this
                /// pollable is ready, `check-write` will return `ok(n)` with n>0, or an
                /// error.
                ///
                /// If the stream is closed, this pollable is always ready immediately.
                ///
                /// The created `pollable` is a child resource of the `output-stream`.
                /// Implementations may trap if the `output-stream` is dropped before
                /// all derived `pollable`s created with this function are dropped.
                #[allow(async_fn_in_trait)]
                pub fn subscribe(&self) -> Pollable {
                    unsafe {
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        let ret = wit_import0((self).handle() as i32);
                        super::super::super::wasi::io::poll::Pollable::from_handle(
                            ret as u32,
                        )
                    }
                }
            }
            impl OutputStream {
                #[allow(unused_unsafe, clippy::all)]
                /// Write zeroes to a stream.
                ///
                /// This should be used precisely like `write` with the exact same
                /// preconditions (must use check-write first), but instead of
                /// passing a list of bytes, you simply pass the number of zero-bytes
                /// that should be written.
                #[allow(async_fn_in_trait)]
                pub fn write_zeroes(&self, len: u64) -> Result<(), StreamError> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 12],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(&len), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result6 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                    let v5 = match l3 {
                                        0 => {
                                            let e5 = {
                                                let l4 = *ptr0.add(8).cast::<i32>();
                                                super::super::super::wasi::io::error::Error::from_handle(
                                                    l4 as u32,
                                                )
                                            };
                                            StreamError::LastOperationFailed(e5)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &1) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            StreamError::Closed
                                        }
                                    };
                                    v5
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl OutputStream {
                #[allow(unused_unsafe, clippy::all)]
                /// Perform a write of up to 4096 zeroes, and then flush the stream.
                /// Block until all of these operations are complete, or an error
                /// occurs.
                ///
                /// This is a convenience wrapper around the use of `check-write`,
                /// `subscribe`, `write-zeroes`, and `flush`, and is implemented with
                /// the following pseudo-code:
                ///
                /// ```text
                /// let pollable = this.subscribe();
                /// while num_zeroes != 0 {
                /// // Wait for the stream to become writable
                /// pollable.block();
                /// let Ok(n) = this.check-write(); // eliding error handling
                /// let len = min(n, num_zeroes);
                /// this.write-zeroes(len);         // eliding error handling
                /// num_zeroes -= len;
                /// }
                /// this.flush();
                /// // Wait for completion of `flush`
                /// pollable.block();
                /// // Check for any errors that arose during `flush`
                /// let _ = this.check-write();         // eliding error handling
                /// ```
                #[allow(async_fn_in_trait)]
                pub fn blocking_write_zeroes_and_flush(
                    &self,
                    len: u64,
                ) -> Result<(), StreamError> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 12],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(&len), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result6 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                    let v5 = match l3 {
                                        0 => {
                                            let e5 = {
                                                let l4 = *ptr0.add(8).cast::<i32>();
                                                super::super::super::wasi::io::error::Error::from_handle(
                                                    l4 as u32,
                                                )
                                            };
                                            StreamError::LastOperationFailed(e5)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &1) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            StreamError::Closed
                                        }
                                    };
                                    v5
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl OutputStream {
                #[allow(unused_unsafe, clippy::all)]
                /// Read from one stream and write to another.
                ///
                /// The behavior of splice is equivelant to:
                /// 1. calling `check-write` on the `output-stream`
                /// 2. calling `read` on the `input-stream` with the smaller of the
                /// `check-write` permitted length and the `len` provided to `splice`
                /// 3. calling `write` on the `output-stream` with that read data.
                ///
                /// Any error reported by the call to `check-write`, `read`, or
                /// `write` ends the splice and reports that error.
                ///
                /// This function returns the number of bytes transferred; it may be less
                /// than `len`.
                #[allow(async_fn_in_trait)]
                pub fn splice(
                    &self,
                    src: &InputStream,
                    len: u64,
                ) -> Result<u64, StreamError> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(
                            _: i32,
                            _: i32,
                            _: i64,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1(
                            (self).handle() as i32,
                            (src).handle() as i32,
                            _rt::as_i64(&len),
                            ptr0,
                        );
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result7 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    let v6 = match l4 {
                                        0 => {
                                            let e6 = {
                                                let l5 = *ptr0.add(12).cast::<i32>();
                                                super::super::super::wasi::io::error::Error::from_handle(
                                                    l5 as u32,
                                                )
                                            };
                                            StreamError::LastOperationFailed(e6)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &1) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            StreamError::Closed
                                        }
                                    };
                                    v6
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result7
                    }
                }
            }
            impl OutputStream {
                #[allow(unused_unsafe, clippy::all)]
                /// Read from one stream and write to another, with blocking.
                ///
                /// This is similar to `splice`, except that it blocks until the
                /// `output-stream` is ready for writing, and the `input-stream`
                /// is ready for reading, before performing the `splice`.
                #[allow(async_fn_in_trait)]
                pub fn blocking_splice(
                    &self,
                    src: &InputStream,
                    len: u64,
                ) -> Result<u64, StreamError> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(
                            _: i32,
                            _: i32,
                            _: i64,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1(
                            (self).handle() as i32,
                            (src).handle() as i32,
                            _rt::as_i64(&len),
                            ptr0,
                        );
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result7 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    let v6 = match l4 {
                                        0 => {
                                            let e6 = {
                                                let l5 = *ptr0.add(12).cast::<i32>();
                                                super::super::super::wasi::io::error::Error::from_handle(
                                                    l5 as u32,
                                                )
                                            };
                                            StreamError::LastOperationFailed(e6)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &1) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            StreamError::Closed
                                        }
                                    };
                                    v6
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result7
                    }
                }
            }
        }
    }
    pub mod random {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod random {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn get_random_bytes(len: u64) -> _rt::Vec<u8> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    unsafe extern "C" fn wit_import1(_: i64, _: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import1(_rt::as_i64(&len), ptr0);
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len4 = l3;
                    let result5 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                    result5
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn get_random_u64() -> u64 {
                unsafe {
                    unsafe extern "C" fn wit_import0() -> i64 {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    let ret = wit_import0();
                    ret as u64
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod insecure {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn get_insecure_random_bytes(len: u64) -> _rt::Vec<u8> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    unsafe extern "C" fn wit_import1(_: i64, _: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import1(_rt::as_i64(&len), ptr0);
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len4 = l3;
                    let result5 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                    result5
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn get_insecure_random_u64() -> u64 {
                unsafe {
                    unsafe extern "C" fn wit_import0() -> i64 {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    let ret = wit_import0();
                    ret as u64
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod insecure_seed {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn insecure_seed() -> (u64, u64) {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import1(ptr0);
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i64>();
                    let result4 = (l2 as u64, l3 as u64);
                    result4
                }
            }
        }
    }
    pub mod sockets {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod network {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[repr(transparent)]
            pub struct Network {
                handle: _rt::Resource<Network>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Network {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Network",
                        "handle",
                        &&self.handle,
                    )
                }
            }
            impl Network {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for Network {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    unsafe extern "C" fn drop(_: i32) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    unsafe {
                        drop(_handle as i32);
                    }
                }
            }
            #[repr(u8)]
            pub enum ErrorCode {
                Unknown,
                AccessDenied,
                NotSupported,
                InvalidArgument,
                OutOfMemory,
                Timeout,
                ConcurrencyConflict,
                NotInProgress,
                WouldBlock,
                InvalidState,
                NewSocketLimit,
                AddressNotBindable,
                AddressInUse,
                RemoteUnreachable,
                ConnectionRefused,
                ConnectionReset,
                ConnectionAborted,
                DatagramTooLarge,
                NameUnresolvable,
                TemporaryResolverFailure,
                PermanentResolverFailure,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ErrorCode {
                #[inline]
                fn clone(&self) -> ErrorCode {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ErrorCode {}
            #[automatically_derived]
            impl ::core::cmp::Eq for ErrorCode {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for ErrorCode {
                #[inline]
                fn cmp(&self, other: &ErrorCode) -> ::core::cmp::Ordering {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ErrorCode {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ErrorCode {
                #[inline]
                fn eq(&self, other: &ErrorCode) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for ErrorCode {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &ErrorCode,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
                }
            }
            impl ErrorCode {
                pub fn name(&self) -> &'static str {
                    match self {
                        ErrorCode::Unknown => "unknown",
                        ErrorCode::AccessDenied => "access-denied",
                        ErrorCode::NotSupported => "not-supported",
                        ErrorCode::InvalidArgument => "invalid-argument",
                        ErrorCode::OutOfMemory => "out-of-memory",
                        ErrorCode::Timeout => "timeout",
                        ErrorCode::ConcurrencyConflict => "concurrency-conflict",
                        ErrorCode::NotInProgress => "not-in-progress",
                        ErrorCode::WouldBlock => "would-block",
                        ErrorCode::InvalidState => "invalid-state",
                        ErrorCode::NewSocketLimit => "new-socket-limit",
                        ErrorCode::AddressNotBindable => "address-not-bindable",
                        ErrorCode::AddressInUse => "address-in-use",
                        ErrorCode::RemoteUnreachable => "remote-unreachable",
                        ErrorCode::ConnectionRefused => "connection-refused",
                        ErrorCode::ConnectionReset => "connection-reset",
                        ErrorCode::ConnectionAborted => "connection-aborted",
                        ErrorCode::DatagramTooLarge => "datagram-too-large",
                        ErrorCode::NameUnresolvable => "name-unresolvable",
                        ErrorCode::TemporaryResolverFailure => {
                            "temporary-resolver-failure"
                        }
                        ErrorCode::PermanentResolverFailure => {
                            "permanent-resolver-failure"
                        }
                    }
                }
                pub fn message(&self) -> &'static str {
                    match self {
                        ErrorCode::Unknown => "",
                        ErrorCode::AccessDenied => "",
                        ErrorCode::NotSupported => "",
                        ErrorCode::InvalidArgument => "",
                        ErrorCode::OutOfMemory => "",
                        ErrorCode::Timeout => "",
                        ErrorCode::ConcurrencyConflict => "",
                        ErrorCode::NotInProgress => "",
                        ErrorCode::WouldBlock => "",
                        ErrorCode::InvalidState => "",
                        ErrorCode::NewSocketLimit => "",
                        ErrorCode::AddressNotBindable => "",
                        ErrorCode::AddressInUse => "",
                        ErrorCode::RemoteUnreachable => "",
                        ErrorCode::ConnectionRefused => "",
                        ErrorCode::ConnectionReset => "",
                        ErrorCode::ConnectionAborted => "",
                        ErrorCode::DatagramTooLarge => "",
                        ErrorCode::NameUnresolvable => "",
                        ErrorCode::TemporaryResolverFailure => "",
                        ErrorCode::PermanentResolverFailure => "",
                    }
                }
            }
            impl ::core::fmt::Debug for ErrorCode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ErrorCode")
                        .field("code", &(*self as i32))
                        .field("name", &self.name())
                        .field("message", &self.message())
                        .finish()
                }
            }
            impl ::core::fmt::Display for ErrorCode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.write_fmt(
                        format_args!("{0} (error {1})", self.name(), *self as i32),
                    )
                }
            }
            impl ::core::error::Error for ErrorCode {}
            impl ErrorCode {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> ErrorCode {
                    if !true {
                        return unsafe { ::core::mem::transmute(val) };
                    }
                    match val {
                        0 => ErrorCode::Unknown,
                        1 => ErrorCode::AccessDenied,
                        2 => ErrorCode::NotSupported,
                        3 => ErrorCode::InvalidArgument,
                        4 => ErrorCode::OutOfMemory,
                        5 => ErrorCode::Timeout,
                        6 => ErrorCode::ConcurrencyConflict,
                        7 => ErrorCode::NotInProgress,
                        8 => ErrorCode::WouldBlock,
                        9 => ErrorCode::InvalidState,
                        10 => ErrorCode::NewSocketLimit,
                        11 => ErrorCode::AddressNotBindable,
                        12 => ErrorCode::AddressInUse,
                        13 => ErrorCode::RemoteUnreachable,
                        14 => ErrorCode::ConnectionRefused,
                        15 => ErrorCode::ConnectionReset,
                        16 => ErrorCode::ConnectionAborted,
                        17 => ErrorCode::DatagramTooLarge,
                        18 => ErrorCode::NameUnresolvable,
                        19 => ErrorCode::TemporaryResolverFailure,
                        20 => ErrorCode::PermanentResolverFailure,
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("invalid enum discriminant"),
                            );
                        }
                    }
                }
            }
            #[repr(u8)]
            pub enum IpAddressFamily {
                Ipv4,
                Ipv6,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for IpAddressFamily {
                #[inline]
                fn clone(&self) -> IpAddressFamily {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for IpAddressFamily {}
            #[automatically_derived]
            impl ::core::cmp::Eq for IpAddressFamily {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for IpAddressFamily {
                #[inline]
                fn cmp(&self, other: &IpAddressFamily) -> ::core::cmp::Ordering {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for IpAddressFamily {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for IpAddressFamily {
                #[inline]
                fn eq(&self, other: &IpAddressFamily) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for IpAddressFamily {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &IpAddressFamily,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
                }
            }
            impl ::core::fmt::Debug for IpAddressFamily {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        IpAddressFamily::Ipv4 => {
                            f.debug_tuple("IpAddressFamily::Ipv4").finish()
                        }
                        IpAddressFamily::Ipv6 => {
                            f.debug_tuple("IpAddressFamily::Ipv6").finish()
                        }
                    }
                }
            }
            impl IpAddressFamily {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> IpAddressFamily {
                    if !true {
                        return unsafe { ::core::mem::transmute(val) };
                    }
                    match val {
                        0 => IpAddressFamily::Ipv4,
                        1 => IpAddressFamily::Ipv6,
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("invalid enum discriminant"),
                            );
                        }
                    }
                }
            }
            pub type Ipv4Address = (u8, u8, u8, u8);
            pub type Ipv6Address = (u16, u16, u16, u16, u16, u16, u16, u16);
            pub enum IpAddress {
                Ipv4(Ipv4Address),
                Ipv6(Ipv6Address),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for IpAddress {
                #[inline]
                fn clone(&self) -> IpAddress {
                    let _: ::core::clone::AssertParamIsClone<Ipv4Address>;
                    let _: ::core::clone::AssertParamIsClone<Ipv6Address>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for IpAddress {}
            impl ::core::fmt::Debug for IpAddress {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        IpAddress::Ipv4(e) => {
                            f.debug_tuple("IpAddress::Ipv4").field(e).finish()
                        }
                        IpAddress::Ipv6(e) => {
                            f.debug_tuple("IpAddress::Ipv6").field(e).finish()
                        }
                    }
                }
            }
            #[repr(C)]
            pub struct Ipv4SocketAddress {
                pub port: u16,
                pub address: Ipv4Address,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Ipv4SocketAddress {
                #[inline]
                fn clone(&self) -> Ipv4SocketAddress {
                    let _: ::core::clone::AssertParamIsClone<u16>;
                    let _: ::core::clone::AssertParamIsClone<Ipv4Address>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Ipv4SocketAddress {}
            impl ::core::fmt::Debug for Ipv4SocketAddress {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Ipv4SocketAddress")
                        .field("port", &self.port)
                        .field("address", &self.address)
                        .finish()
                }
            }
            #[repr(C)]
            pub struct Ipv6SocketAddress {
                pub port: u16,
                pub flow_info: u32,
                pub address: Ipv6Address,
                pub scope_id: u32,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Ipv6SocketAddress {
                #[inline]
                fn clone(&self) -> Ipv6SocketAddress {
                    let _: ::core::clone::AssertParamIsClone<u16>;
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    let _: ::core::clone::AssertParamIsClone<Ipv6Address>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Ipv6SocketAddress {}
            impl ::core::fmt::Debug for Ipv6SocketAddress {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Ipv6SocketAddress")
                        .field("port", &self.port)
                        .field("flow-info", &self.flow_info)
                        .field("address", &self.address)
                        .field("scope-id", &self.scope_id)
                        .finish()
                }
            }
            pub enum IpSocketAddress {
                Ipv4(Ipv4SocketAddress),
                Ipv6(Ipv6SocketAddress),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for IpSocketAddress {
                #[inline]
                fn clone(&self) -> IpSocketAddress {
                    let _: ::core::clone::AssertParamIsClone<Ipv4SocketAddress>;
                    let _: ::core::clone::AssertParamIsClone<Ipv6SocketAddress>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for IpSocketAddress {}
            impl ::core::fmt::Debug for IpSocketAddress {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        IpSocketAddress::Ipv4(e) => {
                            f.debug_tuple("IpSocketAddress::Ipv4").field(e).finish()
                        }
                        IpSocketAddress::Ipv6(e) => {
                            f.debug_tuple("IpSocketAddress::Ipv6").field(e).finish()
                        }
                    }
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod instance_network {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            pub type Network = super::super::super::wasi::sockets::network::Network;
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn instance_network() -> Network {
                unsafe {
                    unsafe extern "C" fn wit_import0() -> i32 {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    let ret = wit_import0();
                    super::super::super::wasi::sockets::network::Network::from_handle(
                        ret as u32,
                    )
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod udp {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Pollable = super::super::super::wasi::io::poll::Pollable;
            pub type Network = super::super::super::wasi::sockets::network::Network;
            pub type ErrorCode = super::super::super::wasi::sockets::network::ErrorCode;
            pub type IpSocketAddress = super::super::super::wasi::sockets::network::IpSocketAddress;
            pub type IpAddressFamily = super::super::super::wasi::sockets::network::IpAddressFamily;
            pub struct IncomingDatagram {
                pub data: _rt::Vec<u8>,
                pub remote_address: IpSocketAddress,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for IncomingDatagram {
                #[inline]
                fn clone(&self) -> IncomingDatagram {
                    IncomingDatagram {
                        data: ::core::clone::Clone::clone(&self.data),
                        remote_address: ::core::clone::Clone::clone(&self.remote_address),
                    }
                }
            }
            impl ::core::fmt::Debug for IncomingDatagram {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("IncomingDatagram")
                        .field("data", &self.data)
                        .field("remote-address", &self.remote_address)
                        .finish()
                }
            }
            pub struct OutgoingDatagram {
                pub data: _rt::Vec<u8>,
                pub remote_address: Option<IpSocketAddress>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for OutgoingDatagram {
                #[inline]
                fn clone(&self) -> OutgoingDatagram {
                    OutgoingDatagram {
                        data: ::core::clone::Clone::clone(&self.data),
                        remote_address: ::core::clone::Clone::clone(&self.remote_address),
                    }
                }
            }
            impl ::core::fmt::Debug for OutgoingDatagram {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("OutgoingDatagram")
                        .field("data", &self.data)
                        .field("remote-address", &self.remote_address)
                        .finish()
                }
            }
            #[repr(transparent)]
            pub struct UdpSocket {
                handle: _rt::Resource<UdpSocket>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for UdpSocket {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "UdpSocket",
                        "handle",
                        &&self.handle,
                    )
                }
            }
            impl UdpSocket {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for UdpSocket {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    unsafe extern "C" fn drop(_: i32) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    unsafe {
                        drop(_handle as i32);
                    }
                }
            }
            #[repr(transparent)]
            pub struct IncomingDatagramStream {
                handle: _rt::Resource<IncomingDatagramStream>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for IncomingDatagramStream {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "IncomingDatagramStream",
                        "handle",
                        &&self.handle,
                    )
                }
            }
            impl IncomingDatagramStream {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for IncomingDatagramStream {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    unsafe extern "C" fn drop(_: i32) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    unsafe {
                        drop(_handle as i32);
                    }
                }
            }
            #[repr(transparent)]
            pub struct OutgoingDatagramStream {
                handle: _rt::Resource<OutgoingDatagramStream>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for OutgoingDatagramStream {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "OutgoingDatagramStream",
                        "handle",
                        &&self.handle,
                    )
                }
            }
            impl OutgoingDatagramStream {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for OutgoingDatagramStream {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    unsafe extern "C" fn drop(_: i32) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    unsafe {
                        drop(_handle as i32);
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn start_bind(
                    &self,
                    network: &Network,
                    local_address: IpSocketAddress,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        use super::super::super::wasi::sockets::network::IpSocketAddress as V4;
                        let (
                            result5_0,
                            result5_1,
                            result5_2,
                            result5_3,
                            result5_4,
                            result5_5,
                            result5_6,
                            result5_7,
                            result5_8,
                            result5_9,
                            result5_10,
                            result5_11,
                        ) = match local_address {
                            V4::Ipv4(e) => {
                                let super::super::super::wasi::sockets::network::Ipv4SocketAddress {
                                    port: port0,
                                    address: address0,
                                } = e;
                                let (t1_0, t1_1, t1_2, t1_3) = address0;
                                (
                                    0i32,
                                    _rt::as_i32(port0),
                                    _rt::as_i32(t1_0),
                                    _rt::as_i32(t1_1),
                                    _rt::as_i32(t1_2),
                                    _rt::as_i32(t1_3),
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                )
                            }
                            V4::Ipv6(e) => {
                                let super::super::super::wasi::sockets::network::Ipv6SocketAddress {
                                    port: port2,
                                    flow_info: flow_info2,
                                    address: address2,
                                    scope_id: scope_id2,
                                } = e;
                                let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7) = address2;
                                (
                                    1i32,
                                    _rt::as_i32(port2),
                                    _rt::as_i32(flow_info2),
                                    _rt::as_i32(t3_0),
                                    _rt::as_i32(t3_1),
                                    _rt::as_i32(t3_2),
                                    _rt::as_i32(t3_3),
                                    _rt::as_i32(t3_4),
                                    _rt::as_i32(t3_5),
                                    _rt::as_i32(t3_6),
                                    _rt::as_i32(t3_7),
                                    _rt::as_i32(scope_id2),
                                )
                            }
                        };
                        let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import7(
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import7(
                            (self).handle() as i32,
                            (network).handle() as i32,
                            result5_0,
                            result5_1,
                            result5_2,
                            result5_3,
                            result5_4,
                            result5_5,
                            result5_6,
                            result5_7,
                            result5_8,
                            result5_9,
                            result5_10,
                            result5_11,
                            ptr6,
                        );
                        let l8 = i32::from(*ptr6.add(0).cast::<u8>());
                        let result10 = match l8 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l9 = i32::from(*ptr6.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l9 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result10
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn finish_bind(&self) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn stream(
                    &self,
                    remote_address: Option<IpSocketAddress>,
                ) -> Result<
                    (IncomingDatagramStream, OutgoingDatagramStream),
                    ErrorCode,
                > {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 12],
                        );
                        let (
                            result6_0,
                            result6_1,
                            result6_2,
                            result6_3,
                            result6_4,
                            result6_5,
                            result6_6,
                            result6_7,
                            result6_8,
                            result6_9,
                            result6_10,
                            result6_11,
                            result6_12,
                        ) = match remote_address {
                            Some(e) => {
                                use super::super::super::wasi::sockets::network::IpSocketAddress as V4;
                                let (
                                    result5_0,
                                    result5_1,
                                    result5_2,
                                    result5_3,
                                    result5_4,
                                    result5_5,
                                    result5_6,
                                    result5_7,
                                    result5_8,
                                    result5_9,
                                    result5_10,
                                    result5_11,
                                ) = match e {
                                    V4::Ipv4(e) => {
                                        let super::super::super::wasi::sockets::network::Ipv4SocketAddress {
                                            port: port0,
                                            address: address0,
                                        } = e;
                                        let (t1_0, t1_1, t1_2, t1_3) = address0;
                                        (
                                            0i32,
                                            _rt::as_i32(port0),
                                            _rt::as_i32(t1_0),
                                            _rt::as_i32(t1_1),
                                            _rt::as_i32(t1_2),
                                            _rt::as_i32(t1_3),
                                            0i32,
                                            0i32,
                                            0i32,
                                            0i32,
                                            0i32,
                                            0i32,
                                        )
                                    }
                                    V4::Ipv6(e) => {
                                        let super::super::super::wasi::sockets::network::Ipv6SocketAddress {
                                            port: port2,
                                            flow_info: flow_info2,
                                            address: address2,
                                            scope_id: scope_id2,
                                        } = e;
                                        let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7) = address2;
                                        (
                                            1i32,
                                            _rt::as_i32(port2),
                                            _rt::as_i32(flow_info2),
                                            _rt::as_i32(t3_0),
                                            _rt::as_i32(t3_1),
                                            _rt::as_i32(t3_2),
                                            _rt::as_i32(t3_3),
                                            _rt::as_i32(t3_4),
                                            _rt::as_i32(t3_5),
                                            _rt::as_i32(t3_6),
                                            _rt::as_i32(t3_7),
                                            _rt::as_i32(scope_id2),
                                        )
                                    }
                                };
                                (
                                    1i32,
                                    result5_0,
                                    result5_1,
                                    result5_2,
                                    result5_3,
                                    result5_4,
                                    result5_5,
                                    result5_6,
                                    result5_7,
                                    result5_8,
                                    result5_9,
                                    result5_10,
                                    result5_11,
                                )
                            }
                            None => {
                                (
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                )
                            }
                        };
                        let ptr7 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import8(
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import8(
                            (self).handle() as i32,
                            result6_0,
                            result6_1,
                            result6_2,
                            result6_3,
                            result6_4,
                            result6_5,
                            result6_6,
                            result6_7,
                            result6_8,
                            result6_9,
                            result6_10,
                            result6_11,
                            result6_12,
                            ptr7,
                        );
                        let l9 = i32::from(*ptr7.add(0).cast::<u8>());
                        let result13 = match l9 {
                            0 => {
                                let e = {
                                    let l10 = *ptr7.add(4).cast::<i32>();
                                    let l11 = *ptr7.add(8).cast::<i32>();
                                    (
                                        IncomingDatagramStream::from_handle(l10 as u32),
                                        OutgoingDatagramStream::from_handle(l11 as u32),
                                    )
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l12 = i32::from(*ptr7.add(4).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l12 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result13
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn local_address(&self) -> Result<IpSocketAddress, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 36]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 36],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result22 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                    use super::super::super::wasi::sockets::network::IpSocketAddress as V20;
                                    let v20 = match l3 {
                                        0 => {
                                            let e20 = {
                                                let l4 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l5 = i32::from(*ptr0.add(10).cast::<u8>());
                                                let l6 = i32::from(*ptr0.add(11).cast::<u8>());
                                                let l7 = i32::from(*ptr0.add(12).cast::<u8>());
                                                let l8 = i32::from(*ptr0.add(13).cast::<u8>());
                                                super::super::super::wasi::sockets::network::Ipv4SocketAddress {
                                                    port: l4 as u16,
                                                    address: (l5 as u8, l6 as u8, l7 as u8, l8 as u8),
                                                }
                                            };
                                            V20::Ipv4(e20)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &1) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            let e20 = {
                                                let l9 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l10 = *ptr0.add(12).cast::<i32>();
                                                let l11 = i32::from(*ptr0.add(16).cast::<u16>());
                                                let l12 = i32::from(*ptr0.add(18).cast::<u16>());
                                                let l13 = i32::from(*ptr0.add(20).cast::<u16>());
                                                let l14 = i32::from(*ptr0.add(22).cast::<u16>());
                                                let l15 = i32::from(*ptr0.add(24).cast::<u16>());
                                                let l16 = i32::from(*ptr0.add(26).cast::<u16>());
                                                let l17 = i32::from(*ptr0.add(28).cast::<u16>());
                                                let l18 = i32::from(*ptr0.add(30).cast::<u16>());
                                                let l19 = *ptr0.add(32).cast::<i32>();
                                                super::super::super::wasi::sockets::network::Ipv6SocketAddress {
                                                    port: l9 as u16,
                                                    flow_info: l10 as u32,
                                                    address: (
                                                        l11 as u16,
                                                        l12 as u16,
                                                        l13 as u16,
                                                        l14 as u16,
                                                        l15 as u16,
                                                        l16 as u16,
                                                        l17 as u16,
                                                        l18 as u16,
                                                    ),
                                                    scope_id: l19 as u32,
                                                }
                                            };
                                            V20::Ipv6(e20)
                                        }
                                    };
                                    v20
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l21 = i32::from(*ptr0.add(4).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l21 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result22
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn remote_address(&self) -> Result<IpSocketAddress, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 36]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 36],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result22 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                    use super::super::super::wasi::sockets::network::IpSocketAddress as V20;
                                    let v20 = match l3 {
                                        0 => {
                                            let e20 = {
                                                let l4 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l5 = i32::from(*ptr0.add(10).cast::<u8>());
                                                let l6 = i32::from(*ptr0.add(11).cast::<u8>());
                                                let l7 = i32::from(*ptr0.add(12).cast::<u8>());
                                                let l8 = i32::from(*ptr0.add(13).cast::<u8>());
                                                super::super::super::wasi::sockets::network::Ipv4SocketAddress {
                                                    port: l4 as u16,
                                                    address: (l5 as u8, l6 as u8, l7 as u8, l8 as u8),
                                                }
                                            };
                                            V20::Ipv4(e20)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &1) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            let e20 = {
                                                let l9 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l10 = *ptr0.add(12).cast::<i32>();
                                                let l11 = i32::from(*ptr0.add(16).cast::<u16>());
                                                let l12 = i32::from(*ptr0.add(18).cast::<u16>());
                                                let l13 = i32::from(*ptr0.add(20).cast::<u16>());
                                                let l14 = i32::from(*ptr0.add(22).cast::<u16>());
                                                let l15 = i32::from(*ptr0.add(24).cast::<u16>());
                                                let l16 = i32::from(*ptr0.add(26).cast::<u16>());
                                                let l17 = i32::from(*ptr0.add(28).cast::<u16>());
                                                let l18 = i32::from(*ptr0.add(30).cast::<u16>());
                                                let l19 = *ptr0.add(32).cast::<i32>();
                                                super::super::super::wasi::sockets::network::Ipv6SocketAddress {
                                                    port: l9 as u16,
                                                    flow_info: l10 as u32,
                                                    address: (
                                                        l11 as u16,
                                                        l12 as u16,
                                                        l13 as u16,
                                                        l14 as u16,
                                                        l15 as u16,
                                                        l16 as u16,
                                                        l17 as u16,
                                                        l18 as u16,
                                                    ),
                                                    scope_id: l19 as u32,
                                                }
                                            };
                                            V20::Ipv6(e20)
                                        }
                                    };
                                    v20
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l21 = i32::from(*ptr0.add(4).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l21 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result22
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn address_family(&self) -> IpAddressFamily {
                    unsafe {
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        let ret = wit_import0((self).handle() as i32);
                        super::super::super::wasi::sockets::network::IpAddressFamily::_lift(
                            ret as u8,
                        )
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn unicast_hop_limit(&self) -> Result<u8, ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    l3 as u8
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_unicast_hop_limit(&self, value: u8) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, _rt::as_i32(&value), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn receive_buffer_size(&self) -> Result<u64, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_receive_buffer_size(
                    &self,
                    value: u64,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(&value), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn send_buffer_size(&self) -> Result<u64, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_send_buffer_size(&self, value: u64) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(&value), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn subscribe(&self) -> Pollable {
                    unsafe {
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        let ret = wit_import0((self).handle() as i32);
                        super::super::super::wasi::io::poll::Pollable::from_handle(
                            ret as u32,
                        )
                    }
                }
            }
            impl IncomingDatagramStream {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn receive(
                    &self,
                    max_results: u64,
                ) -> Result<_rt::Vec<IncomingDatagram>, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1(
                            (self).handle() as i32,
                            _rt::as_i64(&max_results),
                            ptr0,
                        );
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result28 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l4 = *ptr0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base26 = l3;
                                    let len26 = l4;
                                    let mut result26 = _rt::Vec::with_capacity(len26);
                                    for i in 0..len26 {
                                        let base = base26
                                            .add(i * (32 + 2 * ::core::mem::size_of::<*const u8>()));
                                        let e26 = {
                                            let l5 = *base.add(0).cast::<*mut u8>();
                                            let l6 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len7 = l6;
                                            let l8 = i32::from(
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            use super::super::super::wasi::sockets::network::IpSocketAddress as V25;
                                            let v25 = match l8 {
                                                0 => {
                                                    let e25 = {
                                                        let l9 = i32::from(
                                                            *base
                                                                .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u16>(),
                                                        );
                                                        let l10 = i32::from(
                                                            *base
                                                                .add(6 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u8>(),
                                                        );
                                                        let l11 = i32::from(
                                                            *base
                                                                .add(7 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u8>(),
                                                        );
                                                        let l12 = i32::from(
                                                            *base
                                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u8>(),
                                                        );
                                                        let l13 = i32::from(
                                                            *base
                                                                .add(9 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u8>(),
                                                        );
                                                        super::super::super::wasi::sockets::network::Ipv4SocketAddress {
                                                            port: l9 as u16,
                                                            address: (l10 as u8, l11 as u8, l12 as u8, l13 as u8),
                                                        }
                                                    };
                                                    V25::Ipv4(e25)
                                                }
                                                n => {
                                                    if true {
                                                        match (&n, &1) {
                                                            (left_val, right_val) => {
                                                                if !(*left_val == *right_val) {
                                                                    let kind = ::core::panicking::AssertKind::Eq;
                                                                    ::core::panicking::assert_failed(
                                                                        kind,
                                                                        &*left_val,
                                                                        &*right_val,
                                                                        ::core::option::Option::Some(
                                                                            format_args!("invalid enum discriminant"),
                                                                        ),
                                                                    );
                                                                }
                                                            }
                                                        };
                                                    }
                                                    let e25 = {
                                                        let l14 = i32::from(
                                                            *base
                                                                .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u16>(),
                                                        );
                                                        let l15 = *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>();
                                                        let l16 = i32::from(
                                                            *base
                                                                .add(12 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u16>(),
                                                        );
                                                        let l17 = i32::from(
                                                            *base
                                                                .add(14 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u16>(),
                                                        );
                                                        let l18 = i32::from(
                                                            *base
                                                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u16>(),
                                                        );
                                                        let l19 = i32::from(
                                                            *base
                                                                .add(18 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u16>(),
                                                        );
                                                        let l20 = i32::from(
                                                            *base
                                                                .add(20 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u16>(),
                                                        );
                                                        let l21 = i32::from(
                                                            *base
                                                                .add(22 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u16>(),
                                                        );
                                                        let l22 = i32::from(
                                                            *base
                                                                .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u16>(),
                                                        );
                                                        let l23 = i32::from(
                                                            *base
                                                                .add(26 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u16>(),
                                                        );
                                                        let l24 = *base
                                                            .add(28 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>();
                                                        super::super::super::wasi::sockets::network::Ipv6SocketAddress {
                                                            port: l14 as u16,
                                                            flow_info: l15 as u32,
                                                            address: (
                                                                l16 as u16,
                                                                l17 as u16,
                                                                l18 as u16,
                                                                l19 as u16,
                                                                l20 as u16,
                                                                l21 as u16,
                                                                l22 as u16,
                                                                l23 as u16,
                                                            ),
                                                            scope_id: l24 as u32,
                                                        }
                                                    };
                                                    V25::Ipv6(e25)
                                                }
                                            };
                                            IncomingDatagram {
                                                data: _rt::Vec::from_raw_parts(l5.cast(), len7, len7),
                                                remote_address: v25,
                                            }
                                        };
                                        result26.push(e26);
                                    }
                                    _rt::cabi_dealloc(
                                        base26,
                                        len26 * (32 + 2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    result26
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l27 = i32::from(
                                        *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l27 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result28
                    }
                }
            }
            impl IncomingDatagramStream {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn subscribe(&self) -> Pollable {
                    unsafe {
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        let ret = wit_import0((self).handle() as i32);
                        super::super::super::wasi::io::poll::Pollable::from_handle(
                            ret as u32,
                        )
                    }
                }
            }
            impl OutgoingDatagramStream {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn check_send(&self) -> Result<u64, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl OutgoingDatagramStream {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn send(
                    &self,
                    datagrams: &[OutgoingDatagram],
                ) -> Result<u64, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let vec7 = datagrams;
                        let len7 = vec7.len();
                        let layout7 = _rt::alloc::Layout::from_size_align(
                                vec7.len() * (32 + 3 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            )
                            .unwrap();
                        let (result7, _cleanup7) = wit_bindgen::rt::Cleanup::new(
                            layout7,
                        );
                        for (i, e) in vec7.into_iter().enumerate() {
                            let base = result7
                                .add(i * (32 + 3 * ::core::mem::size_of::<*const u8>()));
                            {
                                let OutgoingDatagram {
                                    data: data0,
                                    remote_address: remote_address0,
                                } = e;
                                let vec1 = data0;
                                let ptr1 = vec1.as_ptr().cast::<u8>();
                                let len1 = vec1.len();
                                *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len1;
                                *base.add(0).cast::<*mut u8>() = ptr1.cast_mut();
                                match remote_address0 {
                                    Some(e) => {
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (1i32) as u8;
                                        use super::super::super::wasi::sockets::network::IpSocketAddress as V6;
                                        match e {
                                            V6::Ipv4(e) => {
                                                *base
                                                    .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (0i32) as u8;
                                                let super::super::super::wasi::sockets::network::Ipv4SocketAddress {
                                                    port: port2,
                                                    address: address2,
                                                } = e;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u16>() = (_rt::as_i32(port2)) as u16;
                                                let (t3_0, t3_1, t3_2, t3_3) = address2;
                                                *base
                                                    .add(10 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (_rt::as_i32(t3_0)) as u8;
                                                *base
                                                    .add(11 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (_rt::as_i32(t3_1)) as u8;
                                                *base
                                                    .add(12 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (_rt::as_i32(t3_2)) as u8;
                                                *base
                                                    .add(13 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (_rt::as_i32(t3_3)) as u8;
                                            }
                                            V6::Ipv6(e) => {
                                                *base
                                                    .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (1i32) as u8;
                                                let super::super::super::wasi::sockets::network::Ipv6SocketAddress {
                                                    port: port4,
                                                    flow_info: flow_info4,
                                                    address: address4,
                                                    scope_id: scope_id4,
                                                } = e;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u16>() = (_rt::as_i32(port4)) as u16;
                                                *base
                                                    .add(12 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i32>() = _rt::as_i32(flow_info4);
                                                let (t5_0, t5_1, t5_2, t5_3, t5_4, t5_5, t5_6, t5_7) = address4;
                                                *base
                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u16>() = (_rt::as_i32(t5_0)) as u16;
                                                *base
                                                    .add(18 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u16>() = (_rt::as_i32(t5_1)) as u16;
                                                *base
                                                    .add(20 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u16>() = (_rt::as_i32(t5_2)) as u16;
                                                *base
                                                    .add(22 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u16>() = (_rt::as_i32(t5_3)) as u16;
                                                *base
                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u16>() = (_rt::as_i32(t5_4)) as u16;
                                                *base
                                                    .add(26 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u16>() = (_rt::as_i32(t5_5)) as u16;
                                                *base
                                                    .add(28 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u16>() = (_rt::as_i32(t5_6)) as u16;
                                                *base
                                                    .add(30 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u16>() = (_rt::as_i32(t5_7)) as u16;
                                                *base
                                                    .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i32>() = _rt::as_i32(scope_id4);
                                            }
                                        }
                                    }
                                    None => {
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (0i32) as u8;
                                    }
                                };
                            }
                        }
                        let ptr8 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import9(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import9((self).handle() as i32, result7, len7, ptr8);
                        let l10 = i32::from(*ptr8.add(0).cast::<u8>());
                        let result13 = match l10 {
                            0 => {
                                let e = {
                                    let l11 = *ptr8.add(8).cast::<i64>();
                                    l11 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l12 = i32::from(*ptr8.add(8).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l12 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result13
                    }
                }
            }
            impl OutgoingDatagramStream {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn subscribe(&self) -> Pollable {
                    unsafe {
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        let ret = wit_import0((self).handle() as i32);
                        super::super::super::wasi::io::poll::Pollable::from_handle(
                            ret as u32,
                        )
                    }
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod udp_create_socket {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type ErrorCode = super::super::super::wasi::sockets::network::ErrorCode;
            pub type IpAddressFamily = super::super::super::wasi::sockets::network::IpAddressFamily;
            pub type UdpSocket = super::super::super::wasi::sockets::udp::UdpSocket;
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn create_udp_socket(
                address_family: IpAddressFamily,
            ) -> Result<UdpSocket, ErrorCode> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import1(address_family.clone() as i32, ptr0);
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result5 = match l2 {
                        0 => {
                            let e = {
                                let l3 = *ptr0.add(4).cast::<i32>();
                                super::super::super::wasi::sockets::udp::UdpSocket::from_handle(
                                    l3 as u32,
                                )
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                                super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                    l4 as u8,
                                )
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result5
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod tcp {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type InputStream = super::super::super::wasi::io::streams::InputStream;
            pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
            pub type Pollable = super::super::super::wasi::io::poll::Pollable;
            pub type Duration = super::super::super::wasi::clocks::monotonic_clock::Duration;
            pub type Network = super::super::super::wasi::sockets::network::Network;
            pub type ErrorCode = super::super::super::wasi::sockets::network::ErrorCode;
            pub type IpSocketAddress = super::super::super::wasi::sockets::network::IpSocketAddress;
            pub type IpAddressFamily = super::super::super::wasi::sockets::network::IpAddressFamily;
            #[repr(u8)]
            pub enum ShutdownType {
                Receive,
                Send,
                Both,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ShutdownType {
                #[inline]
                fn clone(&self) -> ShutdownType {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ShutdownType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for ShutdownType {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for ShutdownType {
                #[inline]
                fn cmp(&self, other: &ShutdownType) -> ::core::cmp::Ordering {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ShutdownType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ShutdownType {
                #[inline]
                fn eq(&self, other: &ShutdownType) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for ShutdownType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &ShutdownType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
                }
            }
            impl ::core::fmt::Debug for ShutdownType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        ShutdownType::Receive => {
                            f.debug_tuple("ShutdownType::Receive").finish()
                        }
                        ShutdownType::Send => {
                            f.debug_tuple("ShutdownType::Send").finish()
                        }
                        ShutdownType::Both => {
                            f.debug_tuple("ShutdownType::Both").finish()
                        }
                    }
                }
            }
            impl ShutdownType {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> ShutdownType {
                    if !true {
                        return unsafe { ::core::mem::transmute(val) };
                    }
                    match val {
                        0 => ShutdownType::Receive,
                        1 => ShutdownType::Send,
                        2 => ShutdownType::Both,
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("invalid enum discriminant"),
                            );
                        }
                    }
                }
            }
            #[repr(transparent)]
            pub struct TcpSocket {
                handle: _rt::Resource<TcpSocket>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for TcpSocket {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "TcpSocket",
                        "handle",
                        &&self.handle,
                    )
                }
            }
            impl TcpSocket {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for TcpSocket {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    unsafe extern "C" fn drop(_: i32) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    unsafe {
                        drop(_handle as i32);
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn start_bind(
                    &self,
                    network: &Network,
                    local_address: IpSocketAddress,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        use super::super::super::wasi::sockets::network::IpSocketAddress as V4;
                        let (
                            result5_0,
                            result5_1,
                            result5_2,
                            result5_3,
                            result5_4,
                            result5_5,
                            result5_6,
                            result5_7,
                            result5_8,
                            result5_9,
                            result5_10,
                            result5_11,
                        ) = match local_address {
                            V4::Ipv4(e) => {
                                let super::super::super::wasi::sockets::network::Ipv4SocketAddress {
                                    port: port0,
                                    address: address0,
                                } = e;
                                let (t1_0, t1_1, t1_2, t1_3) = address0;
                                (
                                    0i32,
                                    _rt::as_i32(port0),
                                    _rt::as_i32(t1_0),
                                    _rt::as_i32(t1_1),
                                    _rt::as_i32(t1_2),
                                    _rt::as_i32(t1_3),
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                )
                            }
                            V4::Ipv6(e) => {
                                let super::super::super::wasi::sockets::network::Ipv6SocketAddress {
                                    port: port2,
                                    flow_info: flow_info2,
                                    address: address2,
                                    scope_id: scope_id2,
                                } = e;
                                let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7) = address2;
                                (
                                    1i32,
                                    _rt::as_i32(port2),
                                    _rt::as_i32(flow_info2),
                                    _rt::as_i32(t3_0),
                                    _rt::as_i32(t3_1),
                                    _rt::as_i32(t3_2),
                                    _rt::as_i32(t3_3),
                                    _rt::as_i32(t3_4),
                                    _rt::as_i32(t3_5),
                                    _rt::as_i32(t3_6),
                                    _rt::as_i32(t3_7),
                                    _rt::as_i32(scope_id2),
                                )
                            }
                        };
                        let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import7(
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import7(
                            (self).handle() as i32,
                            (network).handle() as i32,
                            result5_0,
                            result5_1,
                            result5_2,
                            result5_3,
                            result5_4,
                            result5_5,
                            result5_6,
                            result5_7,
                            result5_8,
                            result5_9,
                            result5_10,
                            result5_11,
                            ptr6,
                        );
                        let l8 = i32::from(*ptr6.add(0).cast::<u8>());
                        let result10 = match l8 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l9 = i32::from(*ptr6.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l9 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result10
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn finish_bind(&self) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn start_connect(
                    &self,
                    network: &Network,
                    remote_address: IpSocketAddress,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        use super::super::super::wasi::sockets::network::IpSocketAddress as V4;
                        let (
                            result5_0,
                            result5_1,
                            result5_2,
                            result5_3,
                            result5_4,
                            result5_5,
                            result5_6,
                            result5_7,
                            result5_8,
                            result5_9,
                            result5_10,
                            result5_11,
                        ) = match remote_address {
                            V4::Ipv4(e) => {
                                let super::super::super::wasi::sockets::network::Ipv4SocketAddress {
                                    port: port0,
                                    address: address0,
                                } = e;
                                let (t1_0, t1_1, t1_2, t1_3) = address0;
                                (
                                    0i32,
                                    _rt::as_i32(port0),
                                    _rt::as_i32(t1_0),
                                    _rt::as_i32(t1_1),
                                    _rt::as_i32(t1_2),
                                    _rt::as_i32(t1_3),
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                )
                            }
                            V4::Ipv6(e) => {
                                let super::super::super::wasi::sockets::network::Ipv6SocketAddress {
                                    port: port2,
                                    flow_info: flow_info2,
                                    address: address2,
                                    scope_id: scope_id2,
                                } = e;
                                let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7) = address2;
                                (
                                    1i32,
                                    _rt::as_i32(port2),
                                    _rt::as_i32(flow_info2),
                                    _rt::as_i32(t3_0),
                                    _rt::as_i32(t3_1),
                                    _rt::as_i32(t3_2),
                                    _rt::as_i32(t3_3),
                                    _rt::as_i32(t3_4),
                                    _rt::as_i32(t3_5),
                                    _rt::as_i32(t3_6),
                                    _rt::as_i32(t3_7),
                                    _rt::as_i32(scope_id2),
                                )
                            }
                        };
                        let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import7(
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import7(
                            (self).handle() as i32,
                            (network).handle() as i32,
                            result5_0,
                            result5_1,
                            result5_2,
                            result5_3,
                            result5_4,
                            result5_5,
                            result5_6,
                            result5_7,
                            result5_8,
                            result5_9,
                            result5_10,
                            result5_11,
                            ptr6,
                        );
                        let l8 = i32::from(*ptr6.add(0).cast::<u8>());
                        let result10 = match l8 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l9 = i32::from(*ptr6.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l9 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result10
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn finish_connect(
                    &self,
                ) -> Result<(InputStream, OutputStream), ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 12],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result6 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    let l4 = *ptr0.add(8).cast::<i32>();
                                    (
                                        super::super::super::wasi::io::streams::InputStream::from_handle(
                                            l3 as u32,
                                        ),
                                        super::super::super::wasi::io::streams::OutputStream::from_handle(
                                            l4 as u32,
                                        ),
                                    )
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = i32::from(*ptr0.add(4).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l5 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn start_listen(&self) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn finish_listen(&self) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn accept(
                    &self,
                ) -> Result<(TcpSocket, InputStream, OutputStream), ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result7 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    let l4 = *ptr0.add(8).cast::<i32>();
                                    let l5 = *ptr0.add(12).cast::<i32>();
                                    (
                                        TcpSocket::from_handle(l3 as u32),
                                        super::super::super::wasi::io::streams::InputStream::from_handle(
                                            l4 as u32,
                                        ),
                                        super::super::super::wasi::io::streams::OutputStream::from_handle(
                                            l5 as u32,
                                        ),
                                    )
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l6 = i32::from(*ptr0.add(4).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l6 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result7
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn local_address(&self) -> Result<IpSocketAddress, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 36]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 36],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result22 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                    use super::super::super::wasi::sockets::network::IpSocketAddress as V20;
                                    let v20 = match l3 {
                                        0 => {
                                            let e20 = {
                                                let l4 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l5 = i32::from(*ptr0.add(10).cast::<u8>());
                                                let l6 = i32::from(*ptr0.add(11).cast::<u8>());
                                                let l7 = i32::from(*ptr0.add(12).cast::<u8>());
                                                let l8 = i32::from(*ptr0.add(13).cast::<u8>());
                                                super::super::super::wasi::sockets::network::Ipv4SocketAddress {
                                                    port: l4 as u16,
                                                    address: (l5 as u8, l6 as u8, l7 as u8, l8 as u8),
                                                }
                                            };
                                            V20::Ipv4(e20)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &1) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            let e20 = {
                                                let l9 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l10 = *ptr0.add(12).cast::<i32>();
                                                let l11 = i32::from(*ptr0.add(16).cast::<u16>());
                                                let l12 = i32::from(*ptr0.add(18).cast::<u16>());
                                                let l13 = i32::from(*ptr0.add(20).cast::<u16>());
                                                let l14 = i32::from(*ptr0.add(22).cast::<u16>());
                                                let l15 = i32::from(*ptr0.add(24).cast::<u16>());
                                                let l16 = i32::from(*ptr0.add(26).cast::<u16>());
                                                let l17 = i32::from(*ptr0.add(28).cast::<u16>());
                                                let l18 = i32::from(*ptr0.add(30).cast::<u16>());
                                                let l19 = *ptr0.add(32).cast::<i32>();
                                                super::super::super::wasi::sockets::network::Ipv6SocketAddress {
                                                    port: l9 as u16,
                                                    flow_info: l10 as u32,
                                                    address: (
                                                        l11 as u16,
                                                        l12 as u16,
                                                        l13 as u16,
                                                        l14 as u16,
                                                        l15 as u16,
                                                        l16 as u16,
                                                        l17 as u16,
                                                        l18 as u16,
                                                    ),
                                                    scope_id: l19 as u32,
                                                }
                                            };
                                            V20::Ipv6(e20)
                                        }
                                    };
                                    v20
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l21 = i32::from(*ptr0.add(4).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l21 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result22
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn remote_address(&self) -> Result<IpSocketAddress, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 36]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 36],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result22 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                    use super::super::super::wasi::sockets::network::IpSocketAddress as V20;
                                    let v20 = match l3 {
                                        0 => {
                                            let e20 = {
                                                let l4 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l5 = i32::from(*ptr0.add(10).cast::<u8>());
                                                let l6 = i32::from(*ptr0.add(11).cast::<u8>());
                                                let l7 = i32::from(*ptr0.add(12).cast::<u8>());
                                                let l8 = i32::from(*ptr0.add(13).cast::<u8>());
                                                super::super::super::wasi::sockets::network::Ipv4SocketAddress {
                                                    port: l4 as u16,
                                                    address: (l5 as u8, l6 as u8, l7 as u8, l8 as u8),
                                                }
                                            };
                                            V20::Ipv4(e20)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &1) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            let e20 = {
                                                let l9 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l10 = *ptr0.add(12).cast::<i32>();
                                                let l11 = i32::from(*ptr0.add(16).cast::<u16>());
                                                let l12 = i32::from(*ptr0.add(18).cast::<u16>());
                                                let l13 = i32::from(*ptr0.add(20).cast::<u16>());
                                                let l14 = i32::from(*ptr0.add(22).cast::<u16>());
                                                let l15 = i32::from(*ptr0.add(24).cast::<u16>());
                                                let l16 = i32::from(*ptr0.add(26).cast::<u16>());
                                                let l17 = i32::from(*ptr0.add(28).cast::<u16>());
                                                let l18 = i32::from(*ptr0.add(30).cast::<u16>());
                                                let l19 = *ptr0.add(32).cast::<i32>();
                                                super::super::super::wasi::sockets::network::Ipv6SocketAddress {
                                                    port: l9 as u16,
                                                    flow_info: l10 as u32,
                                                    address: (
                                                        l11 as u16,
                                                        l12 as u16,
                                                        l13 as u16,
                                                        l14 as u16,
                                                        l15 as u16,
                                                        l16 as u16,
                                                        l17 as u16,
                                                        l18 as u16,
                                                    ),
                                                    scope_id: l19 as u32,
                                                }
                                            };
                                            V20::Ipv6(e20)
                                        }
                                    };
                                    v20
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l21 = i32::from(*ptr0.add(4).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l21 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result22
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn is_listening(&self) -> bool {
                    unsafe {
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        let ret = wit_import0((self).handle() as i32);
                        _rt::bool_lift(ret as u8)
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn address_family(&self) -> IpAddressFamily {
                    unsafe {
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        let ret = wit_import0((self).handle() as i32);
                        super::super::super::wasi::sockets::network::IpAddressFamily::_lift(
                            ret as u8,
                        )
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_listen_backlog_size(
                    &self,
                    value: u64,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(&value), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn keep_alive_enabled(&self) -> Result<bool, ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    _rt::bool_lift(l3 as u8)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_keep_alive_enabled(
                    &self,
                    value: bool,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1(
                            (self).handle() as i32,
                            match &value {
                                true => 1,
                                false => 0,
                            },
                            ptr0,
                        );
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn keep_alive_idle_time(&self) -> Result<Duration, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_keep_alive_idle_time(
                    &self,
                    value: Duration,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(value), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn keep_alive_interval(&self) -> Result<Duration, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_keep_alive_interval(
                    &self,
                    value: Duration,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(value), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn keep_alive_count(&self) -> Result<u32, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    l3 as u32
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_keep_alive_count(&self, value: u32) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, _rt::as_i32(&value), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn hop_limit(&self) -> Result<u8, ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    l3 as u8
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_hop_limit(&self, value: u8) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, _rt::as_i32(&value), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn receive_buffer_size(&self) -> Result<u64, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_receive_buffer_size(
                    &self,
                    value: u64,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(&value), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn send_buffer_size(&self) -> Result<u64, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_send_buffer_size(&self, value: u64) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(&value), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn subscribe(&self) -> Pollable {
                    unsafe {
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        let ret = wit_import0((self).handle() as i32);
                        super::super::super::wasi::io::poll::Pollable::from_handle(
                            ret as u32,
                        )
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn shutdown(
                    &self,
                    shutdown_type: ShutdownType,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1(
                            (self).handle() as i32,
                            shutdown_type.clone() as i32,
                            ptr0,
                        );
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod tcp_create_socket {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type ErrorCode = super::super::super::wasi::sockets::network::ErrorCode;
            pub type IpAddressFamily = super::super::super::wasi::sockets::network::IpAddressFamily;
            pub type TcpSocket = super::super::super::wasi::sockets::tcp::TcpSocket;
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn create_tcp_socket(
                address_family: IpAddressFamily,
            ) -> Result<TcpSocket, ErrorCode> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import1(address_family.clone() as i32, ptr0);
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result5 = match l2 {
                        0 => {
                            let e = {
                                let l3 = *ptr0.add(4).cast::<i32>();
                                super::super::super::wasi::sockets::tcp::TcpSocket::from_handle(
                                    l3 as u32,
                                )
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                                super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                    l4 as u8,
                                )
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result5
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod ip_name_lookup {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Pollable = super::super::super::wasi::io::poll::Pollable;
            pub type Network = super::super::super::wasi::sockets::network::Network;
            pub type ErrorCode = super::super::super::wasi::sockets::network::ErrorCode;
            pub type IpAddress = super::super::super::wasi::sockets::network::IpAddress;
            #[repr(transparent)]
            pub struct ResolveAddressStream {
                handle: _rt::Resource<ResolveAddressStream>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ResolveAddressStream {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "ResolveAddressStream",
                        "handle",
                        &&self.handle,
                    )
                }
            }
            impl ResolveAddressStream {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for ResolveAddressStream {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    unsafe extern "C" fn drop(_: i32) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    unsafe {
                        drop(_handle as i32);
                    }
                }
            }
            impl ResolveAddressStream {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn resolve_next_address(
                    &self,
                ) -> Result<Option<IpAddress>, ErrorCode> {
                    unsafe {
                        #[repr(align(2))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 22]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 22],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result19 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(2).cast::<u8>());
                                    match l3 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                                                use super::super::super::wasi::sockets::network::IpAddress as V17;
                                                let v17 = match l4 {
                                                    0 => {
                                                        let e17 = {
                                                            let l5 = i32::from(*ptr0.add(6).cast::<u8>());
                                                            let l6 = i32::from(*ptr0.add(7).cast::<u8>());
                                                            let l7 = i32::from(*ptr0.add(8).cast::<u8>());
                                                            let l8 = i32::from(*ptr0.add(9).cast::<u8>());
                                                            (l5 as u8, l6 as u8, l7 as u8, l8 as u8)
                                                        };
                                                        V17::Ipv4(e17)
                                                    }
                                                    n => {
                                                        if true {
                                                            match (&n, &1) {
                                                                (left_val, right_val) => {
                                                                    if !(*left_val == *right_val) {
                                                                        let kind = ::core::panicking::AssertKind::Eq;
                                                                        ::core::panicking::assert_failed(
                                                                            kind,
                                                                            &*left_val,
                                                                            &*right_val,
                                                                            ::core::option::Option::Some(
                                                                                format_args!("invalid enum discriminant"),
                                                                            ),
                                                                        );
                                                                    }
                                                                }
                                                            };
                                                        }
                                                        let e17 = {
                                                            let l9 = i32::from(*ptr0.add(6).cast::<u16>());
                                                            let l10 = i32::from(*ptr0.add(8).cast::<u16>());
                                                            let l11 = i32::from(*ptr0.add(10).cast::<u16>());
                                                            let l12 = i32::from(*ptr0.add(12).cast::<u16>());
                                                            let l13 = i32::from(*ptr0.add(14).cast::<u16>());
                                                            let l14 = i32::from(*ptr0.add(16).cast::<u16>());
                                                            let l15 = i32::from(*ptr0.add(18).cast::<u16>());
                                                            let l16 = i32::from(*ptr0.add(20).cast::<u16>());
                                                            (
                                                                l9 as u16,
                                                                l10 as u16,
                                                                l11 as u16,
                                                                l12 as u16,
                                                                l13 as u16,
                                                                l14 as u16,
                                                                l15 as u16,
                                                                l16 as u16,
                                                            )
                                                        };
                                                        V17::Ipv6(e17)
                                                    }
                                                };
                                                v17
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l18 = i32::from(*ptr0.add(2).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l18 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result19
                    }
                }
            }
            impl ResolveAddressStream {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn subscribe(&self) -> Pollable {
                    unsafe {
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        let ret = wit_import0((self).handle() as i32);
                        super::super::super::wasi::io::poll::Pollable::from_handle(
                            ret as u32,
                        )
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn resolve_addresses(
                network: &Network,
                name: &str,
            ) -> Result<ResolveAddressStream, ErrorCode> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let vec0 = name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    unsafe extern "C" fn wit_import2(
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import2((network).handle() as i32, ptr0.cast_mut(), len0, ptr1);
                    let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                    let result6 = match l3 {
                        0 => {
                            let e = {
                                let l4 = *ptr1.add(4).cast::<i32>();
                                ResolveAddressStream::from_handle(l4 as u32)
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l5 = i32::from(*ptr1.add(4).cast::<u8>());
                                super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                    l5 as u8,
                                )
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result6
                }
            }
        }
    }
}
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod tangent {
        pub mod logs {
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod mapper {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Logview = super::super::super::super::tangent::logs::log::Logview;
                pub type Scalar = super::super::super::super::tangent::logs::log::Scalar;
                pub struct Meta {
                    pub name: _rt::String,
                    pub version: _rt::String,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Meta {
                    #[inline]
                    fn clone(&self) -> Meta {
                        Meta {
                            name: ::core::clone::Clone::clone(&self.name),
                            version: ::core::clone::Clone::clone(&self.version),
                        }
                    }
                }
                impl ::core::fmt::Debug for Meta {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Meta")
                            .field("name", &self.name)
                            .field("version", &self.version)
                            .finish()
                    }
                }
                pub enum Pred {
                    Has(_rt::String),
                    Eq((_rt::String, Scalar)),
                    Prefix((_rt::String, _rt::String)),
                    In((_rt::String, _rt::Vec<Scalar>)),
                    Gt((_rt::String, f64)),
                    Regex((_rt::String, _rt::String)),
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Pred {
                    #[inline]
                    fn clone(&self) -> Pred {
                        match self {
                            Pred::Has(__self_0) => {
                                Pred::Has(::core::clone::Clone::clone(__self_0))
                            }
                            Pred::Eq(__self_0) => {
                                Pred::Eq(::core::clone::Clone::clone(__self_0))
                            }
                            Pred::Prefix(__self_0) => {
                                Pred::Prefix(::core::clone::Clone::clone(__self_0))
                            }
                            Pred::In(__self_0) => {
                                Pred::In(::core::clone::Clone::clone(__self_0))
                            }
                            Pred::Gt(__self_0) => {
                                Pred::Gt(::core::clone::Clone::clone(__self_0))
                            }
                            Pred::Regex(__self_0) => {
                                Pred::Regex(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Pred {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            Pred::Has(e) => f.debug_tuple("Pred::Has").field(e).finish(),
                            Pred::Eq(e) => f.debug_tuple("Pred::Eq").field(e).finish(),
                            Pred::Prefix(e) => {
                                f.debug_tuple("Pred::Prefix").field(e).finish()
                            }
                            Pred::In(e) => f.debug_tuple("Pred::In").field(e).finish(),
                            Pred::Gt(e) => f.debug_tuple("Pred::Gt").field(e).finish(),
                            Pred::Regex(e) => {
                                f.debug_tuple("Pred::Regex").field(e).finish()
                            }
                        }
                    }
                }
                pub struct Selector {
                    pub any: _rt::Vec<Pred>,
                    /// OR of predicates
                    pub all: _rt::Vec<Pred>,
                    /// AND of predicates
                    pub none: _rt::Vec<Pred>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Selector {
                    #[inline]
                    fn clone(&self) -> Selector {
                        Selector {
                            any: ::core::clone::Clone::clone(&self.any),
                            all: ::core::clone::Clone::clone(&self.all),
                            none: ::core::clone::Clone::clone(&self.none),
                        }
                    }
                }
                impl ::core::fmt::Debug for Selector {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Selector")
                            .field("any", &self.any)
                            .field("all", &self.all)
                            .field("none", &self.none)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case, unused_unsafe)]
                pub unsafe fn _export_metadata_cabi<T: Guest>() -> *mut u8 {
                    unsafe {
                        let result0 = { T::metadata() };
                        let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                        let Meta { name: name2, version: version2 } = result0;
                        let vec3 = (name2.into_bytes()).into_boxed_slice();
                        let ptr3 = vec3.as_ptr().cast::<u8>();
                        let len3 = vec3.len();
                        ::core::mem::forget(vec3);
                        *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                        *ptr1.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                        let vec4 = (version2.into_bytes()).into_boxed_slice();
                        let ptr4 = vec4.as_ptr().cast::<u8>();
                        let len4 = vec4.len();
                        ::core::mem::forget(vec4);
                        *ptr1
                            .add(3 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>() = len4;
                        *ptr1
                            .add(2 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>() = ptr4.cast_mut();
                        ptr1
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_metadata<T: Guest>(arg0: *mut u8) {
                    unsafe {
                        let l0 = *arg0.add(0).cast::<*mut u8>();
                        let l1 = *arg0
                            .add(::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        _rt::cabi_dealloc(l0, l1, 1);
                        let l2 = *arg0
                            .add(2 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>();
                        let l3 = *arg0
                            .add(3 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        _rt::cabi_dealloc(l2, l3, 1);
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case, unused_unsafe)]
                pub unsafe fn _export_probe_cabi<T: Guest>() -> *mut u8 {
                    unsafe {
                        let result0 = { T::probe() };
                        let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                        let vec66 = result0;
                        let len66 = vec66.len();
                        let layout66 = _rt::alloc::Layout::from_size_align(
                                vec66.len() * (6 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            )
                            .unwrap();
                        let (result66, _cleanup66) = wit_bindgen::rt::Cleanup::new(
                            layout66,
                        );
                        if let Some(cleanup) = _cleanup66 {
                            cleanup.forget();
                        }
                        for (i, e) in vec66.into_iter().enumerate() {
                            let base = result66
                                .add(i * (6 * ::core::mem::size_of::<*const u8>()));
                            {
                                let Selector { any: any2, all: all2, none: none2 } = e;
                                let vec23 = any2;
                                let len23 = vec23.len();
                                let layout23 = _rt::alloc::Layout::from_size_align(
                                        vec23.len()
                                            * (16 + 4 * ::core::mem::size_of::<*const u8>()),
                                        8,
                                    )
                                    .unwrap();
                                let (result23, _cleanup23) = wit_bindgen::rt::Cleanup::new(
                                    layout23,
                                );
                                if let Some(cleanup) = _cleanup23 {
                                    cleanup.forget();
                                }
                                for (i, e) in vec23.into_iter().enumerate() {
                                    let base = result23
                                        .add(i * (16 + 4 * ::core::mem::size_of::<*const u8>()));
                                    {
                                        match e {
                                            Pred::Has(e) => {
                                                *base.add(0).cast::<u8>() = (0i32) as u8;
                                                let vec3 = (e.into_bytes()).into_boxed_slice();
                                                let ptr3 = vec3.as_ptr().cast::<u8>();
                                                let len3 = vec3.len();
                                                ::core::mem::forget(vec3);
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len3;
                                                *base.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                                            }
                                            Pred::Eq(e) => {
                                                *base.add(0).cast::<u8>() = (1i32) as u8;
                                                let (t4_0, t4_1) = e;
                                                let vec5 = (t4_0.into_bytes()).into_boxed_slice();
                                                let ptr5 = vec5.as_ptr().cast::<u8>();
                                                let len5 = vec5.len();
                                                ::core::mem::forget(vec5);
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len5;
                                                *base.add(8).cast::<*mut u8>() = ptr5.cast_mut();
                                                use super::super::super::super::tangent::logs::log::Scalar as V8;
                                                match t4_1 {
                                                    V8::Str(e) => {
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (0i32) as u8;
                                                        let vec6 = (e.into_bytes()).into_boxed_slice();
                                                        let ptr6 = vec6.as_ptr().cast::<u8>();
                                                        let len6 = vec6.len();
                                                        ::core::mem::forget(vec6);
                                                        *base
                                                            .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len6;
                                                        *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = ptr6.cast_mut();
                                                    }
                                                    V8::Int(e) => {
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (1i32) as u8;
                                                        *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(e);
                                                    }
                                                    V8::Float(e) => {
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (2i32) as u8;
                                                        *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<f64>() = _rt::as_f64(e);
                                                    }
                                                    V8::Boolean(e) => {
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (3i32) as u8;
                                                        *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                    V8::Bytes(e) => {
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (4i32) as u8;
                                                        let vec7 = (e).into_boxed_slice();
                                                        let ptr7 = vec7.as_ptr().cast::<u8>();
                                                        let len7 = vec7.len();
                                                        ::core::mem::forget(vec7);
                                                        *base
                                                            .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len7;
                                                        *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = ptr7.cast_mut();
                                                    }
                                                }
                                            }
                                            Pred::Prefix(e) => {
                                                *base.add(0).cast::<u8>() = (2i32) as u8;
                                                let (t9_0, t9_1) = e;
                                                let vec10 = (t9_0.into_bytes()).into_boxed_slice();
                                                let ptr10 = vec10.as_ptr().cast::<u8>();
                                                let len10 = vec10.len();
                                                ::core::mem::forget(vec10);
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len10;
                                                *base.add(8).cast::<*mut u8>() = ptr10.cast_mut();
                                                let vec11 = (t9_1.into_bytes()).into_boxed_slice();
                                                let ptr11 = vec11.as_ptr().cast::<u8>();
                                                let len11 = vec11.len();
                                                ::core::mem::forget(vec11);
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len11;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = ptr11.cast_mut();
                                            }
                                            Pred::In(e) => {
                                                *base.add(0).cast::<u8>() = (3i32) as u8;
                                                let (t12_0, t12_1) = e;
                                                let vec13 = (t12_0.into_bytes()).into_boxed_slice();
                                                let ptr13 = vec13.as_ptr().cast::<u8>();
                                                let len13 = vec13.len();
                                                ::core::mem::forget(vec13);
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len13;
                                                *base.add(8).cast::<*mut u8>() = ptr13.cast_mut();
                                                let vec17 = t12_1;
                                                let len17 = vec17.len();
                                                let layout17 = _rt::alloc::Layout::from_size_align(
                                                        vec17.len() * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                        8,
                                                    )
                                                    .unwrap();
                                                let (result17, _cleanup17) = wit_bindgen::rt::Cleanup::new(
                                                    layout17,
                                                );
                                                if let Some(cleanup) = _cleanup17 {
                                                    cleanup.forget();
                                                }
                                                for (i, e) in vec17.into_iter().enumerate() {
                                                    let base = result17
                                                        .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                    {
                                                        use super::super::super::super::tangent::logs::log::Scalar as V16;
                                                        match e {
                                                            V16::Str(e) => {
                                                                *base.add(0).cast::<u8>() = (0i32) as u8;
                                                                let vec14 = (e.into_bytes()).into_boxed_slice();
                                                                let ptr14 = vec14.as_ptr().cast::<u8>();
                                                                let len14 = vec14.len();
                                                                ::core::mem::forget(vec14);
                                                                *base
                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len14;
                                                                *base.add(8).cast::<*mut u8>() = ptr14.cast_mut();
                                                            }
                                                            V16::Int(e) => {
                                                                *base.add(0).cast::<u8>() = (1i32) as u8;
                                                                *base.add(8).cast::<i64>() = _rt::as_i64(e);
                                                            }
                                                            V16::Float(e) => {
                                                                *base.add(0).cast::<u8>() = (2i32) as u8;
                                                                *base.add(8).cast::<f64>() = _rt::as_f64(e);
                                                            }
                                                            V16::Boolean(e) => {
                                                                *base.add(0).cast::<u8>() = (3i32) as u8;
                                                                *base.add(8).cast::<u8>() = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            V16::Bytes(e) => {
                                                                *base.add(0).cast::<u8>() = (4i32) as u8;
                                                                let vec15 = (e).into_boxed_slice();
                                                                let ptr15 = vec15.as_ptr().cast::<u8>();
                                                                let len15 = vec15.len();
                                                                ::core::mem::forget(vec15);
                                                                *base
                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len15;
                                                                *base.add(8).cast::<*mut u8>() = ptr15.cast_mut();
                                                            }
                                                        }
                                                    }
                                                }
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len17;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = result17;
                                            }
                                            Pred::Gt(e) => {
                                                *base.add(0).cast::<u8>() = (4i32) as u8;
                                                let (t18_0, t18_1) = e;
                                                let vec19 = (t18_0.into_bytes()).into_boxed_slice();
                                                let ptr19 = vec19.as_ptr().cast::<u8>();
                                                let len19 = vec19.len();
                                                ::core::mem::forget(vec19);
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len19;
                                                *base.add(8).cast::<*mut u8>() = ptr19.cast_mut();
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<f64>() = _rt::as_f64(t18_1);
                                            }
                                            Pred::Regex(e) => {
                                                *base.add(0).cast::<u8>() = (5i32) as u8;
                                                let (t20_0, t20_1) = e;
                                                let vec21 = (t20_0.into_bytes()).into_boxed_slice();
                                                let ptr21 = vec21.as_ptr().cast::<u8>();
                                                let len21 = vec21.len();
                                                ::core::mem::forget(vec21);
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len21;
                                                *base.add(8).cast::<*mut u8>() = ptr21.cast_mut();
                                                let vec22 = (t20_1.into_bytes()).into_boxed_slice();
                                                let ptr22 = vec22.as_ptr().cast::<u8>();
                                                let len22 = vec22.len();
                                                ::core::mem::forget(vec22);
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len22;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = ptr22.cast_mut();
                                            }
                                        }
                                    }
                                }
                                *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len23;
                                *base.add(0).cast::<*mut u8>() = result23;
                                let vec44 = all2;
                                let len44 = vec44.len();
                                let layout44 = _rt::alloc::Layout::from_size_align(
                                        vec44.len()
                                            * (16 + 4 * ::core::mem::size_of::<*const u8>()),
                                        8,
                                    )
                                    .unwrap();
                                let (result44, _cleanup44) = wit_bindgen::rt::Cleanup::new(
                                    layout44,
                                );
                                if let Some(cleanup) = _cleanup44 {
                                    cleanup.forget();
                                }
                                for (i, e) in vec44.into_iter().enumerate() {
                                    let base = result44
                                        .add(i * (16 + 4 * ::core::mem::size_of::<*const u8>()));
                                    {
                                        match e {
                                            Pred::Has(e) => {
                                                *base.add(0).cast::<u8>() = (0i32) as u8;
                                                let vec24 = (e.into_bytes()).into_boxed_slice();
                                                let ptr24 = vec24.as_ptr().cast::<u8>();
                                                let len24 = vec24.len();
                                                ::core::mem::forget(vec24);
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len24;
                                                *base.add(8).cast::<*mut u8>() = ptr24.cast_mut();
                                            }
                                            Pred::Eq(e) => {
                                                *base.add(0).cast::<u8>() = (1i32) as u8;
                                                let (t25_0, t25_1) = e;
                                                let vec26 = (t25_0.into_bytes()).into_boxed_slice();
                                                let ptr26 = vec26.as_ptr().cast::<u8>();
                                                let len26 = vec26.len();
                                                ::core::mem::forget(vec26);
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len26;
                                                *base.add(8).cast::<*mut u8>() = ptr26.cast_mut();
                                                use super::super::super::super::tangent::logs::log::Scalar as V29;
                                                match t25_1 {
                                                    V29::Str(e) => {
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (0i32) as u8;
                                                        let vec27 = (e.into_bytes()).into_boxed_slice();
                                                        let ptr27 = vec27.as_ptr().cast::<u8>();
                                                        let len27 = vec27.len();
                                                        ::core::mem::forget(vec27);
                                                        *base
                                                            .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len27;
                                                        *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = ptr27.cast_mut();
                                                    }
                                                    V29::Int(e) => {
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (1i32) as u8;
                                                        *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(e);
                                                    }
                                                    V29::Float(e) => {
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (2i32) as u8;
                                                        *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<f64>() = _rt::as_f64(e);
                                                    }
                                                    V29::Boolean(e) => {
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (3i32) as u8;
                                                        *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                    V29::Bytes(e) => {
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (4i32) as u8;
                                                        let vec28 = (e).into_boxed_slice();
                                                        let ptr28 = vec28.as_ptr().cast::<u8>();
                                                        let len28 = vec28.len();
                                                        ::core::mem::forget(vec28);
                                                        *base
                                                            .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len28;
                                                        *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = ptr28.cast_mut();
                                                    }
                                                }
                                            }
                                            Pred::Prefix(e) => {
                                                *base.add(0).cast::<u8>() = (2i32) as u8;
                                                let (t30_0, t30_1) = e;
                                                let vec31 = (t30_0.into_bytes()).into_boxed_slice();
                                                let ptr31 = vec31.as_ptr().cast::<u8>();
                                                let len31 = vec31.len();
                                                ::core::mem::forget(vec31);
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len31;
                                                *base.add(8).cast::<*mut u8>() = ptr31.cast_mut();
                                                let vec32 = (t30_1.into_bytes()).into_boxed_slice();
                                                let ptr32 = vec32.as_ptr().cast::<u8>();
                                                let len32 = vec32.len();
                                                ::core::mem::forget(vec32);
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len32;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = ptr32.cast_mut();
                                            }
                                            Pred::In(e) => {
                                                *base.add(0).cast::<u8>() = (3i32) as u8;
                                                let (t33_0, t33_1) = e;
                                                let vec34 = (t33_0.into_bytes()).into_boxed_slice();
                                                let ptr34 = vec34.as_ptr().cast::<u8>();
                                                let len34 = vec34.len();
                                                ::core::mem::forget(vec34);
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len34;
                                                *base.add(8).cast::<*mut u8>() = ptr34.cast_mut();
                                                let vec38 = t33_1;
                                                let len38 = vec38.len();
                                                let layout38 = _rt::alloc::Layout::from_size_align(
                                                        vec38.len() * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                        8,
                                                    )
                                                    .unwrap();
                                                let (result38, _cleanup38) = wit_bindgen::rt::Cleanup::new(
                                                    layout38,
                                                );
                                                if let Some(cleanup) = _cleanup38 {
                                                    cleanup.forget();
                                                }
                                                for (i, e) in vec38.into_iter().enumerate() {
                                                    let base = result38
                                                        .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                    {
                                                        use super::super::super::super::tangent::logs::log::Scalar as V37;
                                                        match e {
                                                            V37::Str(e) => {
                                                                *base.add(0).cast::<u8>() = (0i32) as u8;
                                                                let vec35 = (e.into_bytes()).into_boxed_slice();
                                                                let ptr35 = vec35.as_ptr().cast::<u8>();
                                                                let len35 = vec35.len();
                                                                ::core::mem::forget(vec35);
                                                                *base
                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len35;
                                                                *base.add(8).cast::<*mut u8>() = ptr35.cast_mut();
                                                            }
                                                            V37::Int(e) => {
                                                                *base.add(0).cast::<u8>() = (1i32) as u8;
                                                                *base.add(8).cast::<i64>() = _rt::as_i64(e);
                                                            }
                                                            V37::Float(e) => {
                                                                *base.add(0).cast::<u8>() = (2i32) as u8;
                                                                *base.add(8).cast::<f64>() = _rt::as_f64(e);
                                                            }
                                                            V37::Boolean(e) => {
                                                                *base.add(0).cast::<u8>() = (3i32) as u8;
                                                                *base.add(8).cast::<u8>() = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            V37::Bytes(e) => {
                                                                *base.add(0).cast::<u8>() = (4i32) as u8;
                                                                let vec36 = (e).into_boxed_slice();
                                                                let ptr36 = vec36.as_ptr().cast::<u8>();
                                                                let len36 = vec36.len();
                                                                ::core::mem::forget(vec36);
                                                                *base
                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len36;
                                                                *base.add(8).cast::<*mut u8>() = ptr36.cast_mut();
                                                            }
                                                        }
                                                    }
                                                }
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len38;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = result38;
                                            }
                                            Pred::Gt(e) => {
                                                *base.add(0).cast::<u8>() = (4i32) as u8;
                                                let (t39_0, t39_1) = e;
                                                let vec40 = (t39_0.into_bytes()).into_boxed_slice();
                                                let ptr40 = vec40.as_ptr().cast::<u8>();
                                                let len40 = vec40.len();
                                                ::core::mem::forget(vec40);
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len40;
                                                *base.add(8).cast::<*mut u8>() = ptr40.cast_mut();
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<f64>() = _rt::as_f64(t39_1);
                                            }
                                            Pred::Regex(e) => {
                                                *base.add(0).cast::<u8>() = (5i32) as u8;
                                                let (t41_0, t41_1) = e;
                                                let vec42 = (t41_0.into_bytes()).into_boxed_slice();
                                                let ptr42 = vec42.as_ptr().cast::<u8>();
                                                let len42 = vec42.len();
                                                ::core::mem::forget(vec42);
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len42;
                                                *base.add(8).cast::<*mut u8>() = ptr42.cast_mut();
                                                let vec43 = (t41_1.into_bytes()).into_boxed_slice();
                                                let ptr43 = vec43.as_ptr().cast::<u8>();
                                                let len43 = vec43.len();
                                                ::core::mem::forget(vec43);
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len43;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = ptr43.cast_mut();
                                            }
                                        }
                                    }
                                }
                                *base
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len44;
                                *base
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>() = result44;
                                let vec65 = none2;
                                let len65 = vec65.len();
                                let layout65 = _rt::alloc::Layout::from_size_align(
                                        vec65.len()
                                            * (16 + 4 * ::core::mem::size_of::<*const u8>()),
                                        8,
                                    )
                                    .unwrap();
                                let (result65, _cleanup65) = wit_bindgen::rt::Cleanup::new(
                                    layout65,
                                );
                                if let Some(cleanup) = _cleanup65 {
                                    cleanup.forget();
                                }
                                for (i, e) in vec65.into_iter().enumerate() {
                                    let base = result65
                                        .add(i * (16 + 4 * ::core::mem::size_of::<*const u8>()));
                                    {
                                        match e {
                                            Pred::Has(e) => {
                                                *base.add(0).cast::<u8>() = (0i32) as u8;
                                                let vec45 = (e.into_bytes()).into_boxed_slice();
                                                let ptr45 = vec45.as_ptr().cast::<u8>();
                                                let len45 = vec45.len();
                                                ::core::mem::forget(vec45);
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len45;
                                                *base.add(8).cast::<*mut u8>() = ptr45.cast_mut();
                                            }
                                            Pred::Eq(e) => {
                                                *base.add(0).cast::<u8>() = (1i32) as u8;
                                                let (t46_0, t46_1) = e;
                                                let vec47 = (t46_0.into_bytes()).into_boxed_slice();
                                                let ptr47 = vec47.as_ptr().cast::<u8>();
                                                let len47 = vec47.len();
                                                ::core::mem::forget(vec47);
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len47;
                                                *base.add(8).cast::<*mut u8>() = ptr47.cast_mut();
                                                use super::super::super::super::tangent::logs::log::Scalar as V50;
                                                match t46_1 {
                                                    V50::Str(e) => {
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (0i32) as u8;
                                                        let vec48 = (e.into_bytes()).into_boxed_slice();
                                                        let ptr48 = vec48.as_ptr().cast::<u8>();
                                                        let len48 = vec48.len();
                                                        ::core::mem::forget(vec48);
                                                        *base
                                                            .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len48;
                                                        *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = ptr48.cast_mut();
                                                    }
                                                    V50::Int(e) => {
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (1i32) as u8;
                                                        *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(e);
                                                    }
                                                    V50::Float(e) => {
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (2i32) as u8;
                                                        *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<f64>() = _rt::as_f64(e);
                                                    }
                                                    V50::Boolean(e) => {
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (3i32) as u8;
                                                        *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                    V50::Bytes(e) => {
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (4i32) as u8;
                                                        let vec49 = (e).into_boxed_slice();
                                                        let ptr49 = vec49.as_ptr().cast::<u8>();
                                                        let len49 = vec49.len();
                                                        ::core::mem::forget(vec49);
                                                        *base
                                                            .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len49;
                                                        *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = ptr49.cast_mut();
                                                    }
                                                }
                                            }
                                            Pred::Prefix(e) => {
                                                *base.add(0).cast::<u8>() = (2i32) as u8;
                                                let (t51_0, t51_1) = e;
                                                let vec52 = (t51_0.into_bytes()).into_boxed_slice();
                                                let ptr52 = vec52.as_ptr().cast::<u8>();
                                                let len52 = vec52.len();
                                                ::core::mem::forget(vec52);
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len52;
                                                *base.add(8).cast::<*mut u8>() = ptr52.cast_mut();
                                                let vec53 = (t51_1.into_bytes()).into_boxed_slice();
                                                let ptr53 = vec53.as_ptr().cast::<u8>();
                                                let len53 = vec53.len();
                                                ::core::mem::forget(vec53);
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len53;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = ptr53.cast_mut();
                                            }
                                            Pred::In(e) => {
                                                *base.add(0).cast::<u8>() = (3i32) as u8;
                                                let (t54_0, t54_1) = e;
                                                let vec55 = (t54_0.into_bytes()).into_boxed_slice();
                                                let ptr55 = vec55.as_ptr().cast::<u8>();
                                                let len55 = vec55.len();
                                                ::core::mem::forget(vec55);
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len55;
                                                *base.add(8).cast::<*mut u8>() = ptr55.cast_mut();
                                                let vec59 = t54_1;
                                                let len59 = vec59.len();
                                                let layout59 = _rt::alloc::Layout::from_size_align(
                                                        vec59.len() * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                        8,
                                                    )
                                                    .unwrap();
                                                let (result59, _cleanup59) = wit_bindgen::rt::Cleanup::new(
                                                    layout59,
                                                );
                                                if let Some(cleanup) = _cleanup59 {
                                                    cleanup.forget();
                                                }
                                                for (i, e) in vec59.into_iter().enumerate() {
                                                    let base = result59
                                                        .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                    {
                                                        use super::super::super::super::tangent::logs::log::Scalar as V58;
                                                        match e {
                                                            V58::Str(e) => {
                                                                *base.add(0).cast::<u8>() = (0i32) as u8;
                                                                let vec56 = (e.into_bytes()).into_boxed_slice();
                                                                let ptr56 = vec56.as_ptr().cast::<u8>();
                                                                let len56 = vec56.len();
                                                                ::core::mem::forget(vec56);
                                                                *base
                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len56;
                                                                *base.add(8).cast::<*mut u8>() = ptr56.cast_mut();
                                                            }
                                                            V58::Int(e) => {
                                                                *base.add(0).cast::<u8>() = (1i32) as u8;
                                                                *base.add(8).cast::<i64>() = _rt::as_i64(e);
                                                            }
                                                            V58::Float(e) => {
                                                                *base.add(0).cast::<u8>() = (2i32) as u8;
                                                                *base.add(8).cast::<f64>() = _rt::as_f64(e);
                                                            }
                                                            V58::Boolean(e) => {
                                                                *base.add(0).cast::<u8>() = (3i32) as u8;
                                                                *base.add(8).cast::<u8>() = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            V58::Bytes(e) => {
                                                                *base.add(0).cast::<u8>() = (4i32) as u8;
                                                                let vec57 = (e).into_boxed_slice();
                                                                let ptr57 = vec57.as_ptr().cast::<u8>();
                                                                let len57 = vec57.len();
                                                                ::core::mem::forget(vec57);
                                                                *base
                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len57;
                                                                *base.add(8).cast::<*mut u8>() = ptr57.cast_mut();
                                                            }
                                                        }
                                                    }
                                                }
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len59;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = result59;
                                            }
                                            Pred::Gt(e) => {
                                                *base.add(0).cast::<u8>() = (4i32) as u8;
                                                let (t60_0, t60_1) = e;
                                                let vec61 = (t60_0.into_bytes()).into_boxed_slice();
                                                let ptr61 = vec61.as_ptr().cast::<u8>();
                                                let len61 = vec61.len();
                                                ::core::mem::forget(vec61);
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len61;
                                                *base.add(8).cast::<*mut u8>() = ptr61.cast_mut();
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<f64>() = _rt::as_f64(t60_1);
                                            }
                                            Pred::Regex(e) => {
                                                *base.add(0).cast::<u8>() = (5i32) as u8;
                                                let (t62_0, t62_1) = e;
                                                let vec63 = (t62_0.into_bytes()).into_boxed_slice();
                                                let ptr63 = vec63.as_ptr().cast::<u8>();
                                                let len63 = vec63.len();
                                                ::core::mem::forget(vec63);
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len63;
                                                *base.add(8).cast::<*mut u8>() = ptr63.cast_mut();
                                                let vec64 = (t62_1.into_bytes()).into_boxed_slice();
                                                let ptr64 = vec64.as_ptr().cast::<u8>();
                                                let len64 = vec64.len();
                                                ::core::mem::forget(vec64);
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len64;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = ptr64.cast_mut();
                                            }
                                        }
                                    }
                                }
                                *base
                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len65;
                                *base
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>() = result65;
                            }
                        }
                        *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len66;
                        *ptr1.add(0).cast::<*mut u8>() = result66;
                        ptr1
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_probe<T: Guest>(arg0: *mut u8) {
                    unsafe {
                        let l0 = *arg0.add(0).cast::<*mut u8>();
                        let l1 = *arg0
                            .add(::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let base107 = l0;
                        let len107 = l1;
                        for i in 0..len107 {
                            let base = base107
                                .add(i * (6 * ::core::mem::size_of::<*const u8>()));
                            {
                                let l2 = *base.add(0).cast::<*mut u8>();
                                let l3 = *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base36 = l2;
                                let len36 = l3;
                                for i in 0..len36 {
                                    let base = base36
                                        .add(i * (16 + 4 * ::core::mem::size_of::<*const u8>()));
                                    {
                                        let l4 = i32::from(*base.add(0).cast::<u8>());
                                        match l4 {
                                            0 => {
                                                let l5 = *base.add(8).cast::<*mut u8>();
                                                let l6 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l5, l6, 1);
                                            }
                                            1 => {
                                                let l7 = *base.add(8).cast::<*mut u8>();
                                                let l8 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l7, l8, 1);
                                                let l9 = i32::from(
                                                    *base
                                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                match l9 {
                                                    0 => {
                                                        let l10 = *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l11 = *base
                                                            .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        _rt::cabi_dealloc(l10, l11, 1);
                                                    }
                                                    1 => {}
                                                    2 => {}
                                                    3 => {}
                                                    _ => {
                                                        let l12 = *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l13 = *base
                                                            .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let base14 = l12;
                                                        let len14 = l13;
                                                        _rt::cabi_dealloc(base14, len14 * 1, 1);
                                                    }
                                                }
                                            }
                                            2 => {
                                                let l15 = *base.add(8).cast::<*mut u8>();
                                                let l16 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l15, l16, 1);
                                                let l17 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l18 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l17, l18, 1);
                                            }
                                            3 => {
                                                let l19 = *base.add(8).cast::<*mut u8>();
                                                let l20 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l19, l20, 1);
                                                let l21 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l22 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let base29 = l21;
                                                let len29 = l22;
                                                for i in 0..len29 {
                                                    let base = base29
                                                        .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                    {
                                                        let l23 = i32::from(*base.add(0).cast::<u8>());
                                                        match l23 {
                                                            0 => {
                                                                let l24 = *base.add(8).cast::<*mut u8>();
                                                                let l25 = *base
                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>();
                                                                _rt::cabi_dealloc(l24, l25, 1);
                                                            }
                                                            1 => {}
                                                            2 => {}
                                                            3 => {}
                                                            _ => {
                                                                let l26 = *base.add(8).cast::<*mut u8>();
                                                                let l27 = *base
                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>();
                                                                let base28 = l26;
                                                                let len28 = l27;
                                                                _rt::cabi_dealloc(base28, len28 * 1, 1);
                                                            }
                                                        }
                                                    }
                                                }
                                                _rt::cabi_dealloc(
                                                    base29,
                                                    len29 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                    8,
                                                );
                                            }
                                            4 => {
                                                let l30 = *base.add(8).cast::<*mut u8>();
                                                let l31 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l30, l31, 1);
                                            }
                                            _ => {
                                                let l32 = *base.add(8).cast::<*mut u8>();
                                                let l33 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l32, l33, 1);
                                                let l34 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l35 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l34, l35, 1);
                                            }
                                        }
                                    }
                                }
                                _rt::cabi_dealloc(
                                    base36,
                                    len36 * (16 + 4 * ::core::mem::size_of::<*const u8>()),
                                    8,
                                );
                                let l37 = *base
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l38 = *base
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base71 = l37;
                                let len71 = l38;
                                for i in 0..len71 {
                                    let base = base71
                                        .add(i * (16 + 4 * ::core::mem::size_of::<*const u8>()));
                                    {
                                        let l39 = i32::from(*base.add(0).cast::<u8>());
                                        match l39 {
                                            0 => {
                                                let l40 = *base.add(8).cast::<*mut u8>();
                                                let l41 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l40, l41, 1);
                                            }
                                            1 => {
                                                let l42 = *base.add(8).cast::<*mut u8>();
                                                let l43 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l42, l43, 1);
                                                let l44 = i32::from(
                                                    *base
                                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                match l44 {
                                                    0 => {
                                                        let l45 = *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l46 = *base
                                                            .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        _rt::cabi_dealloc(l45, l46, 1);
                                                    }
                                                    1 => {}
                                                    2 => {}
                                                    3 => {}
                                                    _ => {
                                                        let l47 = *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l48 = *base
                                                            .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let base49 = l47;
                                                        let len49 = l48;
                                                        _rt::cabi_dealloc(base49, len49 * 1, 1);
                                                    }
                                                }
                                            }
                                            2 => {
                                                let l50 = *base.add(8).cast::<*mut u8>();
                                                let l51 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l50, l51, 1);
                                                let l52 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l53 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l52, l53, 1);
                                            }
                                            3 => {
                                                let l54 = *base.add(8).cast::<*mut u8>();
                                                let l55 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l54, l55, 1);
                                                let l56 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l57 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let base64 = l56;
                                                let len64 = l57;
                                                for i in 0..len64 {
                                                    let base = base64
                                                        .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                    {
                                                        let l58 = i32::from(*base.add(0).cast::<u8>());
                                                        match l58 {
                                                            0 => {
                                                                let l59 = *base.add(8).cast::<*mut u8>();
                                                                let l60 = *base
                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>();
                                                                _rt::cabi_dealloc(l59, l60, 1);
                                                            }
                                                            1 => {}
                                                            2 => {}
                                                            3 => {}
                                                            _ => {
                                                                let l61 = *base.add(8).cast::<*mut u8>();
                                                                let l62 = *base
                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>();
                                                                let base63 = l61;
                                                                let len63 = l62;
                                                                _rt::cabi_dealloc(base63, len63 * 1, 1);
                                                            }
                                                        }
                                                    }
                                                }
                                                _rt::cabi_dealloc(
                                                    base64,
                                                    len64 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                    8,
                                                );
                                            }
                                            4 => {
                                                let l65 = *base.add(8).cast::<*mut u8>();
                                                let l66 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l65, l66, 1);
                                            }
                                            _ => {
                                                let l67 = *base.add(8).cast::<*mut u8>();
                                                let l68 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l67, l68, 1);
                                                let l69 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l70 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l69, l70, 1);
                                            }
                                        }
                                    }
                                }
                                _rt::cabi_dealloc(
                                    base71,
                                    len71 * (16 + 4 * ::core::mem::size_of::<*const u8>()),
                                    8,
                                );
                                let l72 = *base
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l73 = *base
                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base106 = l72;
                                let len106 = l73;
                                for i in 0..len106 {
                                    let base = base106
                                        .add(i * (16 + 4 * ::core::mem::size_of::<*const u8>()));
                                    {
                                        let l74 = i32::from(*base.add(0).cast::<u8>());
                                        match l74 {
                                            0 => {
                                                let l75 = *base.add(8).cast::<*mut u8>();
                                                let l76 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l75, l76, 1);
                                            }
                                            1 => {
                                                let l77 = *base.add(8).cast::<*mut u8>();
                                                let l78 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l77, l78, 1);
                                                let l79 = i32::from(
                                                    *base
                                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                match l79 {
                                                    0 => {
                                                        let l80 = *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l81 = *base
                                                            .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        _rt::cabi_dealloc(l80, l81, 1);
                                                    }
                                                    1 => {}
                                                    2 => {}
                                                    3 => {}
                                                    _ => {
                                                        let l82 = *base
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l83 = *base
                                                            .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let base84 = l82;
                                                        let len84 = l83;
                                                        _rt::cabi_dealloc(base84, len84 * 1, 1);
                                                    }
                                                }
                                            }
                                            2 => {
                                                let l85 = *base.add(8).cast::<*mut u8>();
                                                let l86 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l85, l86, 1);
                                                let l87 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l88 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l87, l88, 1);
                                            }
                                            3 => {
                                                let l89 = *base.add(8).cast::<*mut u8>();
                                                let l90 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l89, l90, 1);
                                                let l91 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l92 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let base99 = l91;
                                                let len99 = l92;
                                                for i in 0..len99 {
                                                    let base = base99
                                                        .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                    {
                                                        let l93 = i32::from(*base.add(0).cast::<u8>());
                                                        match l93 {
                                                            0 => {
                                                                let l94 = *base.add(8).cast::<*mut u8>();
                                                                let l95 = *base
                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>();
                                                                _rt::cabi_dealloc(l94, l95, 1);
                                                            }
                                                            1 => {}
                                                            2 => {}
                                                            3 => {}
                                                            _ => {
                                                                let l96 = *base.add(8).cast::<*mut u8>();
                                                                let l97 = *base
                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>();
                                                                let base98 = l96;
                                                                let len98 = l97;
                                                                _rt::cabi_dealloc(base98, len98 * 1, 1);
                                                            }
                                                        }
                                                    }
                                                }
                                                _rt::cabi_dealloc(
                                                    base99,
                                                    len99 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                    8,
                                                );
                                            }
                                            4 => {
                                                let l100 = *base.add(8).cast::<*mut u8>();
                                                let l101 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l100, l101, 1);
                                            }
                                            _ => {
                                                let l102 = *base.add(8).cast::<*mut u8>();
                                                let l103 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l102, l103, 1);
                                                let l104 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l105 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                _rt::cabi_dealloc(l104, l105, 1);
                                            }
                                        }
                                    }
                                }
                                _rt::cabi_dealloc(
                                    base106,
                                    len106 * (16 + 4 * ::core::mem::size_of::<*const u8>()),
                                    8,
                                );
                            }
                        }
                        _rt::cabi_dealloc(
                            base107,
                            len107 * (6 * ::core::mem::size_of::<*const u8>()),
                            ::core::mem::size_of::<*const u8>(),
                        );
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case, unused_unsafe)]
                pub unsafe fn _export_process_logs_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    unsafe {
                        let result3 = {
                            let handle1;
                            let base2 = arg0;
                            let len2 = arg1;
                            let mut result2 = _rt::Vec::with_capacity(len2);
                            for i in 0..len2 {
                                let base = base2.add(i * 4);
                                let e2 = {
                                    let l0 = *base.add(0).cast::<i32>();
                                    {
                                        handle1 = super::super::super::super::tangent::logs::log::Logview::from_handle(
                                            l0 as u32,
                                        );
                                        &handle1
                                    }
                                };
                                result2.push(e2);
                            }
                            _rt::cabi_dealloc(base2, len2 * 4, 4);
                            T::process_logs(result2)
                        };
                        let ptr4 = (&raw mut _RET_AREA.0).cast::<u8>();
                        match result3 {
                            Ok(e) => {
                                *ptr4.add(0).cast::<u8>() = (0i32) as u8;
                                let vec5 = (e).into_boxed_slice();
                                let ptr5 = vec5.as_ptr().cast::<u8>();
                                let len5 = vec5.len();
                                ::core::mem::forget(vec5);
                                *ptr4
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len5;
                                *ptr4
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>() = ptr5.cast_mut();
                            }
                            Err(e) => {
                                *ptr4.add(0).cast::<u8>() = (1i32) as u8;
                                let vec6 = (e.into_bytes()).into_boxed_slice();
                                let ptr6 = vec6.as_ptr().cast::<u8>();
                                let len6 = vec6.len();
                                ::core::mem::forget(vec6);
                                *ptr4
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len6;
                                *ptr4
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>() = ptr6.cast_mut();
                            }
                        };
                        ptr4
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_process_logs<T: Guest>(arg0: *mut u8) {
                    unsafe {
                        let l0 = i32::from(*arg0.add(0).cast::<u8>());
                        match l0 {
                            0 => {
                                let l1 = *arg0
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l2 = *arg0
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base3 = l1;
                                let len3 = l2;
                                _rt::cabi_dealloc(base3, len3 * 1, 1);
                            }
                            _ => {
                                let l4 = *arg0
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l5 = *arg0
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                _rt::cabi_dealloc(l4, l5, 1);
                            }
                        }
                    }
                }
                pub trait Guest {
                    #[allow(async_fn_in_trait)]
                    fn metadata() -> Meta;
                    #[allow(async_fn_in_trait)]
                    fn probe() -> _rt::Vec<Selector>;
                    #[allow(async_fn_in_trait)]
                    fn process_logs(
                        input: _rt::Vec<&Logview>,
                    ) -> Result<_rt::Vec<u8>, _rt::String>;
                }
                #[doc(hidden)]
                pub(crate) use __export_tangent_logs_mapper_0_1_0_cabi;
                #[repr(align(8))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 4 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 4
                        * ::core::mem::size_of::<*const u8>()],
                );
            }
        }
    }
}
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::vec::Vec;
    pub use alloc_crate::string::String;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if true {
            String::from_utf8(bytes).unwrap()
        } else {
            unsafe { String::from_utf8_unchecked(bytes) }
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        unsafe {
            let layout = alloc::Layout::from_size_align_unchecked(size, align);
            alloc::dealloc(ptr, layout);
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if true {
            {
                ::core::panicking::panic_fmt(format_args!("invalid enum discriminant"));
            }
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    use core::fmt;
    use core::marker;
    use core::sync::atomic::{AtomicU32, Ordering::Relaxed};
    /// A type which represents a component model resource, either imported or
    /// exported into this component.
    ///
    /// This is a low-level wrapper which handles the lifetime of the resource
    /// (namely this has a destructor). The `T` provided defines the component model
    /// intrinsics that this wrapper uses.
    ///
    /// One of the chief purposes of this type is to provide `Deref` implementations
    /// to access the underlying data when it is owned.
    ///
    /// This type is primarily used in generated code for exported and imported
    /// resources.
    #[repr(transparent)]
    pub struct Resource<T: WasmResource> {
        handle: AtomicU32,
        _marker: marker::PhantomData<T>,
    }
    /// A trait which all wasm resources implement, namely providing the ability to
    /// drop a resource.
    ///
    /// This generally is implemented by generated code, not user-facing code.
    #[allow(clippy::missing_safety_doc)]
    pub unsafe trait WasmResource {
        /// Invokes the `[resource-drop]...` intrinsic.
        unsafe fn drop(handle: u32);
    }
    impl<T: WasmResource> Resource<T> {
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
            if true {
                if !(handle != 0 && handle != u32::MAX) {
                    ::core::panicking::panic(
                        "assertion failed: handle != 0 && handle != u32::MAX",
                    )
                }
            }
            Self {
                handle: AtomicU32::new(handle),
                _marker: marker::PhantomData,
            }
        }
        /// Takes ownership of the handle owned by `resource`.
        ///
        /// Note that this ideally would be `into_handle` taking `Resource<T>` by
        /// ownership. The code generator does not enable that in all situations,
        /// unfortunately, so this is provided instead.
        ///
        /// Also note that `take_handle` is in theory only ever called on values
        /// owned by a generated function. For example a generated function might
        /// take `Resource<T>` as an argument but then call `take_handle` on a
        /// reference to that argument. In that sense the dynamic nature of
        /// `take_handle` should only be exposed internally to generated code, not
        /// to user code.
        #[doc(hidden)]
        pub fn take_handle(resource: &Resource<T>) -> u32 {
            resource.handle.swap(u32::MAX, Relaxed)
        }
        #[doc(hidden)]
        pub fn handle(resource: &Resource<T>) -> u32 {
            resource.handle.load(Relaxed)
        }
    }
    impl<T: WasmResource> fmt::Debug for Resource<T> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Resource").field("handle", &self.handle).finish()
        }
    }
    impl<T: WasmResource> Drop for Resource<T> {
        fn drop(&mut self) {
            unsafe {
                match self.handle.load(Relaxed) {
                    u32::MAX => {}
                    other => T::drop(other),
                }
            }
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if true {
            match val {
                0 => false,
                1 => true,
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("invalid bool discriminant"),
                    );
                }
            }
        } else {
            val != 0
        }
    }
    pub use alloc_crate::alloc;
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub fn as_f64<T: AsF64>(t: T) -> f64 {
        t.as_f64()
    }
    pub trait AsF64 {
        fn as_f64(self) -> f64;
    }
    impl<'a, T: Copy + AsF64> AsF64 for &'a T {
        fn as_f64(self) -> f64 {
            (*self).as_f64()
        }
    }
    impl AsF64 for f64 {
        #[inline]
        fn as_f64(self) -> f64 {
            self as f64
        }
    }
    extern crate alloc as alloc_crate;
}
#[doc(inline)]
pub(crate) use __export_processor_impl as export;
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen::rt::maybe_link_cabi_realloc();
}
const _: &[u8] = b"package tangent:logs@0.1.0;\n\ninterface log {\n  variant scalar {\n    str(string),\n    int(s64),\n    float(f64),\n    boolean(bool),\n    bytes(list<u8>),\n  }\n\n  resource logview {\n    // JSONPath/dot-path style, e.g. \"detail.findings[0].CompanyName\"\n    has:      func(path: string) -> bool;\n    get:      func(path: string) -> option<scalar>;\n    len:      func(path: string) -> option<u32>;\n    get-list: func(path: string) -> option<list<scalar>>;\n    get-map:  func(path: string) -> option<list<tuple<string, scalar>>>;\n    keys:     func(path: string) -> list<string>;\n  }\n}\n\n\ninterface mapper {\n  use log.{logview, scalar};\n\n  record meta {\n    name: string,\n    version: string,\n  }\n\n  variant pred {\n    has(string),\n    eq(tuple<string, scalar>),\n    prefix(tuple<string, string>),\n    in(tuple<string, list<scalar>>),\n    gt(tuple<string, f64>),\n    regex(tuple<string, string>),\n  }\n\n  record selector {\n    any: list<pred>,             // OR of predicates\n    all: list<pred>,             // AND of predicates\n    none: list<pred>,            // NOT of predicates\n  }\n\n  metadata: func() -> meta;\n\n  probe: func() -> list<selector>;\n\n  process-logs: func(input: list<borrow<logview>>) -> result<list<u8>, string>;\n}\n\nworld processor {\n  import wasi:cli/environment@0.2.0;\n  import wasi:cli/exit@0.2.0;\n  import wasi:io/error@0.2.0;\n  import wasi:io/poll@0.2.0;\n  import wasi:io/streams@0.2.0;\n  import wasi:cli/stdin@0.2.0;\n  import wasi:cli/stdout@0.2.0;\n  import wasi:cli/stderr@0.2.0;\n  import wasi:cli/terminal-input@0.2.0;\n  import wasi:cli/terminal-output@0.2.0;\n  import wasi:cli/terminal-stdin@0.2.0;\n  import wasi:cli/terminal-stdout@0.2.0;\n  import wasi:cli/terminal-stderr@0.2.0;\n  import wasi:clocks/monotonic-clock@0.2.0;\n  import wasi:clocks/wall-clock@0.2.0;\n  import wasi:filesystem/types@0.2.0;\n  import wasi:filesystem/preopens@0.2.0;\n  import wasi:sockets/network@0.2.0;\n  import wasi:sockets/instance-network@0.2.0;\n  import wasi:sockets/udp@0.2.0;\n  import wasi:sockets/udp-create-socket@0.2.0;\n  import wasi:sockets/tcp@0.2.0;\n  import wasi:sockets/tcp-create-socket@0.2.0;\n  import wasi:sockets/ip-name-lookup@0.2.0;\n  import wasi:random/random@0.2.0;\n  import wasi:random/insecure@0.2.0;\n  import wasi:random/insecure-seed@0.2.0;\n\n  import log;\n  export mapper;\n}";
const _: &[u8] = b"package wasi:cli@0.2.0;\n\ninterface environment {\n  /// Get the POSIX-style environment variables.\n  ///\n  /// Each environment variable is provided as a pair of string variable names\n  /// and string value.\n  ///\n  /// Morally, these are a value import, but until value imports are available\n  /// in the component model, this import function should return the same\n  /// values each time it is called.\n  get-environment: func() -> list<tuple<string, string>>;\n\n  /// Get the POSIX-style arguments to the program.\n  get-arguments: func() -> list<string>;\n\n  /// Return a path that programs should use as their initial current working\n  /// directory, interpreting `.` as shorthand for this.\n  initial-cwd: func() -> option<string>;\n}\n\ninterface exit {\n  /// Exit the current instance and any linked instances.\n  exit: func(status: result);\n}\n\ninterface run {\n  /// Run the program.\n  run: func() -> result;\n}\n\ninterface stdin {\n  use wasi:io/streams@0.2.0.{input-stream};\n\n  get-stdin: func() -> input-stream;\n}\n\ninterface stdout {\n  use wasi:io/streams@0.2.0.{output-stream};\n\n  get-stdout: func() -> output-stream;\n}\n\ninterface stderr {\n  use wasi:io/streams@0.2.0.{output-stream};\n\n  get-stderr: func() -> output-stream;\n}\n\n/// Terminal input.\n///\n/// In the future, this may include functions for disabling echoing,\n/// disabling input buffering so that keyboard events are sent through\n/// immediately, querying supported features, and so on.\ninterface terminal-input {\n  /// The input side of a terminal.\n  resource terminal-input;\n}\n\n/// Terminal output.\n///\n/// In the future, this may include functions for querying the terminal\n/// size, being notified of terminal size changes, querying supported\n/// features, and so on.\ninterface terminal-output {\n  /// The output side of a terminal.\n  resource terminal-output;\n}\n\n/// An interface providing an optional `terminal-input` for stdin as a\n/// link-time authority.\ninterface terminal-stdin {\n  use terminal-input.{terminal-input};\n\n  /// If stdin is connected to a terminal, return a `terminal-input` handle\n  /// allowing further interaction with it.\n  get-terminal-stdin: func() -> option<terminal-input>;\n}\n\n/// An interface providing an optional `terminal-output` for stdout as a\n/// link-time authority.\ninterface terminal-stdout {\n  use terminal-output.{terminal-output};\n\n  /// If stdout is connected to a terminal, return a `terminal-output` handle\n  /// allowing further interaction with it.\n  get-terminal-stdout: func() -> option<terminal-output>;\n}\n\n/// An interface providing an optional `terminal-output` for stderr as a\n/// link-time authority.\ninterface terminal-stderr {\n  use terminal-output.{terminal-output};\n\n  /// If stderr is connected to a terminal, return a `terminal-output` handle\n  /// allowing further interaction with it.\n  get-terminal-stderr: func() -> option<terminal-output>;\n}\n\nworld imports {\n  import environment;\n  import exit;\n  import wasi:io/error@0.2.0;\n  import wasi:io/poll@0.2.0;\n  import wasi:io/streams@0.2.0;\n  import stdin;\n  import stdout;\n  import stderr;\n  import terminal-input;\n  import terminal-output;\n  import terminal-stdin;\n  import terminal-stdout;\n  import terminal-stderr;\n  import wasi:clocks/monotonic-clock@0.2.0;\n  import wasi:clocks/wall-clock@0.2.0;\n  import wasi:filesystem/types@0.2.0;\n  import wasi:filesystem/preopens@0.2.0;\n  import wasi:sockets/network@0.2.0;\n  import wasi:sockets/instance-network@0.2.0;\n  import wasi:sockets/udp@0.2.0;\n  import wasi:sockets/udp-create-socket@0.2.0;\n  import wasi:sockets/tcp@0.2.0;\n  import wasi:sockets/tcp-create-socket@0.2.0;\n  import wasi:sockets/ip-name-lookup@0.2.0;\n  import wasi:random/random@0.2.0;\n  import wasi:random/insecure@0.2.0;\n  import wasi:random/insecure-seed@0.2.0;\n}\nworld command {\n  import environment;\n  import exit;\n  import wasi:io/error@0.2.0;\n  import wasi:io/poll@0.2.0;\n  import wasi:io/streams@0.2.0;\n  import stdin;\n  import stdout;\n  import stderr;\n  import terminal-input;\n  import terminal-output;\n  import terminal-stdin;\n  import terminal-stdout;\n  import terminal-stderr;\n  import wasi:clocks/monotonic-clock@0.2.0;\n  import wasi:clocks/wall-clock@0.2.0;\n  import wasi:filesystem/types@0.2.0;\n  import wasi:filesystem/preopens@0.2.0;\n  import wasi:sockets/network@0.2.0;\n  import wasi:sockets/instance-network@0.2.0;\n  import wasi:sockets/udp@0.2.0;\n  import wasi:sockets/udp-create-socket@0.2.0;\n  import wasi:sockets/tcp@0.2.0;\n  import wasi:sockets/tcp-create-socket@0.2.0;\n  import wasi:sockets/ip-name-lookup@0.2.0;\n  import wasi:random/random@0.2.0;\n  import wasi:random/insecure@0.2.0;\n  import wasi:random/insecure-seed@0.2.0;\n\n  export run;\n}\n";
const _: &[u8] = b"package wasi:clocks@0.2.0;\n\ninterface monotonic-clock {\n  use wasi:io/poll@0.2.0.{pollable};\n\n  type instant = u64;\n\n  type duration = u64;\n\n  now: func() -> instant;\n\n  resolution: func() -> duration;\n\n  subscribe-instant: func(when: instant) -> pollable;\n\n  subscribe-duration: func(when: duration) -> pollable;\n}\n\ninterface wall-clock {\n  record datetime {\n    seconds: u64,\n    nanoseconds: u32,\n  }\n\n  now: func() -> datetime;\n\n  resolution: func() -> datetime;\n}\n\n";
const _: &[u8] = b"package wasi:filesystem@0.2.0;\n\ninterface types {\n  use wasi:io/streams@0.2.0.{input-stream, output-stream, error};\n  use wasi:clocks/wall-clock@0.2.0.{datetime};\n\n  type filesize = u64;\n\n  enum descriptor-type {\n    unknown,\n    block-device,\n    character-device,\n    directory,\n    fifo,\n    symbolic-link,\n    regular-file,\n    socket,\n  }\n\n  flags descriptor-flags {\n    read,\n    write,\n    file-integrity-sync,\n    data-integrity-sync,\n    requested-write-sync,\n    mutate-directory,\n  }\n\n  flags path-flags {\n    symlink-follow,\n  }\n\n  flags open-flags {\n    create,\n    directory,\n    exclusive,\n    truncate,\n  }\n\n  type link-count = u64;\n\n  record descriptor-stat {\n    %type: descriptor-type,\n    link-count: link-count,\n    size: filesize,\n    data-access-timestamp: option<datetime>,\n    data-modification-timestamp: option<datetime>,\n    status-change-timestamp: option<datetime>,\n  }\n\n  variant new-timestamp {\n    no-change,\n    now,\n    timestamp(datetime),\n  }\n\n  record directory-entry {\n    %type: descriptor-type,\n    name: string,\n  }\n\n  enum error-code {\n    access,\n    would-block,\n    already,\n    bad-descriptor,\n    busy,\n    deadlock,\n    quota,\n    exist,\n    file-too-large,\n    illegal-byte-sequence,\n    in-progress,\n    interrupted,\n    invalid,\n    io,\n    is-directory,\n    loop,\n    too-many-links,\n    message-size,\n    name-too-long,\n    no-device,\n    no-entry,\n    no-lock,\n    insufficient-memory,\n    insufficient-space,\n    not-directory,\n    not-empty,\n    not-recoverable,\n    unsupported,\n    no-tty,\n    no-such-device,\n    overflow,\n    not-permitted,\n    pipe,\n    read-only,\n    invalid-seek,\n    text-file-busy,\n    cross-device,\n  }\n\n  enum advice {\n    normal,\n    sequential,\n    random,\n    will-need,\n    dont-need,\n    no-reuse,\n  }\n\n  record metadata-hash-value {\n    lower: u64,\n    upper: u64,\n  }\n\n  resource descriptor {\n    read-via-stream: func(offset: filesize) -> result<input-stream, error-code>;\n    write-via-stream: func(offset: filesize) -> result<output-stream, error-code>;\n    append-via-stream: func() -> result<output-stream, error-code>;\n    advise: func(offset: filesize, length: filesize, advice: advice) -> result<_, error-code>;\n    sync-data: func() -> result<_, error-code>;\n    get-flags: func() -> result<descriptor-flags, error-code>;\n    get-type: func() -> result<descriptor-type, error-code>;\n    set-size: func(size: filesize) -> result<_, error-code>;\n    set-times: func(data-access-timestamp: new-timestamp, data-modification-timestamp: new-timestamp) -> result<_, error-code>;\n    read: func(length: filesize, offset: filesize) -> result<tuple<list<u8>, bool>, error-code>;\n    write: func(buffer: list<u8>, offset: filesize) -> result<filesize, error-code>;\n    read-directory: func() -> result<directory-entry-stream, error-code>;\n    sync: func() -> result<_, error-code>;\n    create-directory-at: func(path: string) -> result<_, error-code>;\n    stat: func() -> result<descriptor-stat, error-code>;\n    stat-at: func(path-flags: path-flags, path: string) -> result<descriptor-stat, error-code>;\n    set-times-at: func(path-flags: path-flags, path: string, data-access-timestamp: new-timestamp, data-modification-timestamp: new-timestamp) -> result<_, error-code>;\n    link-at: func(old-path-flags: path-flags, old-path: string, new-descriptor: borrow<descriptor>, new-path: string) -> result<_, error-code>;\n    open-at: func(path-flags: path-flags, path: string, open-flags: open-flags, %flags: descriptor-flags) -> result<descriptor, error-code>;\n    readlink-at: func(path: string) -> result<string, error-code>;\n    remove-directory-at: func(path: string) -> result<_, error-code>;\n    rename-at: func(old-path: string, new-descriptor: borrow<descriptor>, new-path: string) -> result<_, error-code>;\n    symlink-at: func(old-path: string, new-path: string) -> result<_, error-code>;\n    unlink-file-at: func(path: string) -> result<_, error-code>;\n    is-same-object: func(other: borrow<descriptor>) -> bool;\n    metadata-hash: func() -> result<metadata-hash-value, error-code>;\n    metadata-hash-at: func(path-flags: path-flags, path: string) -> result<metadata-hash-value, error-code>;\n  }\n\n  resource directory-entry-stream {\n    read-directory-entry: func() -> result<option<directory-entry>, error-code>;\n  }\n\n  filesystem-error-code: func(err: borrow<error>) -> option<error-code>;\n}\n\ninterface preopens {\n  use types.{descriptor};\n\n  get-directories: func() -> list<tuple<descriptor, string>>;\n}\n\n";
const _: &[u8] = b"package wasi:io@0.2.0;\n\ninterface error {\n  /// A resource which represents some error information.\n  ///\n  /// The only method provided by this resource is `to-debug-string`,\n  /// which provides some human-readable information about the error.\n  ///\n  /// In the `wasi:io` package, this resource is returned through the\n  /// `wasi:io/streams/stream-error` type.\n  ///\n  /// To provide more specific error information, other interfaces may\n  /// provide functions to further \"downcast\" this error into more specific\n  /// error information. For example, `error`s returned in streams derived\n  /// from filesystem types to be described using the filesystem\'s own\n  /// error-code type, using the function\n  /// `wasi:filesystem/types/filesystem-error-code`, which takes a parameter\n  /// `borrow<error>` and returns\n  /// `option<wasi:filesystem/types/error-code>`.\n  ///\n  /// The set of functions which can \"downcast\" an `error` into a more\n  /// concrete type is open.\n  resource error {\n    /// Returns a string that is suitable to assist humans in debugging\n    /// this error.\n    ///\n    /// WARNING: The returned string should not be consumed mechanically!\n    /// It may change across platforms, hosts, or other implementation\n    /// details. Parsing this string is a major platform-compatibility\n    /// hazard.\n    to-debug-string: func() -> string;\n  }\n}\n\n/// A poll API intended to let users wait for I/O events on multiple handles\n/// at once.\ninterface poll {\n  /// `pollable` represents a single I/O event which may be ready, or not.\n  resource pollable {\n    /// Return the readiness of a pollable. This function never blocks.\n    ///\n    /// Returns `true` when the pollable is ready, and `false` otherwise.\n    ready: func() -> bool;\n    /// `block` returns immediately if the pollable is ready, and otherwise\n    /// blocks until ready.\n    ///\n    /// This function is equivalent to calling `poll.poll` on a list\n    /// containing only this pollable.\n    block: func();\n  }\n\n  /// Poll for completion on a set of pollables.\n  ///\n  /// This function takes a list of pollables, which identify I/O sources of\n  /// interest, and waits until one or more of the events is ready for I/O.\n  ///\n  /// The result `list<u32>` contains one or more indices of handles in the\n  /// argument list that is ready for I/O.\n  ///\n  /// If the list contains more elements than can be indexed with a `u32`\n  /// value, this function traps.\n  ///\n  /// A timeout can be implemented by adding a pollable from the\n  /// wasi-clocks API to the list.\n  ///\n  /// This function does not return a `result`; polling in itself does not\n  /// do any I/O so it doesn\'t fail. If any of the I/O sources identified by\n  /// the pollables has an error, it is indicated by marking the source as\n  /// being reaedy for I/O.\n  poll: func(in: list<borrow<pollable>>) -> list<u32>;\n}\n\n/// WASI I/O is an I/O abstraction API which is currently focused on providing\n/// stream types.\n///\n/// In the future, the component model is expected to add built-in stream types;\n/// when it does, they are expected to subsume this API.\ninterface streams {\n  use error.{error};\n  use poll.{pollable};\n\n  /// An error for input-stream and output-stream operations.\n  variant stream-error {\n    /// The last operation (a write or flush) failed before completion.\n    ///\n    /// More information is available in the `error` payload.\n    last-operation-failed(error),\n    /// The stream is closed: no more input will be accepted by the\n    /// stream. A closed output-stream will return this error on all\n    /// future operations.\n    closed,\n  }\n\n  /// An input bytestream.\n  ///\n  /// `input-stream`s are *non-blocking* to the extent practical on underlying\n  /// platforms. I/O operations always return promptly; if fewer bytes are\n  /// promptly available than requested, they return the number of bytes promptly\n  /// available, which could even be zero. To wait for data to be available,\n  /// use the `subscribe` function to obtain a `pollable` which can be polled\n  /// for using `wasi:io/poll`.\n  resource input-stream {\n    /// Perform a non-blocking read from the stream.\n    ///\n    /// When the source of a `read` is binary data, the bytes from the source\n    /// are returned verbatim. When the source of a `read` is known to the\n    /// implementation to be text, bytes containing the UTF-8 encoding of the\n    /// text are returned.\n    ///\n    /// This function returns a list of bytes containing the read data,\n    /// when successful. The returned list will contain up to `len` bytes;\n    /// it may return fewer than requested, but not more. The list is\n    /// empty when no bytes are available for reading at this time. The\n    /// pollable given by `subscribe` will be ready when more bytes are\n    /// available.\n    ///\n    /// This function fails with a `stream-error` when the operation\n    /// encounters an error, giving `last-operation-failed`, or when the\n    /// stream is closed, giving `closed`.\n    ///\n    /// When the caller gives a `len` of 0, it represents a request to\n    /// read 0 bytes. If the stream is still open, this call should\n    /// succeed and return an empty list, or otherwise fail with `closed`.\n    ///\n    /// The `len` parameter is a `u64`, which could represent a list of u8 which\n    /// is not possible to allocate in wasm32, or not desirable to allocate as\n    /// as a return value by the callee. The callee may return a list of bytes\n    /// less than `len` in size while more bytes are available for reading.\n    read: func(len: u64) -> result<list<u8>, stream-error>;\n    /// Read bytes from a stream, after blocking until at least one byte can\n    /// be read. Except for blocking, behavior is identical to `read`.\n    blocking-read: func(len: u64) -> result<list<u8>, stream-error>;\n    /// Skip bytes from a stream. Returns number of bytes skipped.\n    ///\n    /// Behaves identical to `read`, except instead of returning a list\n    /// of bytes, returns the number of bytes consumed from the stream.\n    skip: func(len: u64) -> result<u64, stream-error>;\n    /// Skip bytes from a stream, after blocking until at least one byte\n    /// can be skipped. Except for blocking behavior, identical to `skip`.\n    blocking-skip: func(len: u64) -> result<u64, stream-error>;\n    /// Create a `pollable` which will resolve once either the specified stream\n    /// has bytes available to read or the other end of the stream has been\n    /// closed.\n    /// The created `pollable` is a child resource of the `input-stream`.\n    /// Implementations may trap if the `input-stream` is dropped before\n    /// all derived `pollable`s created with this function are dropped.\n    subscribe: func() -> pollable;\n  }\n\n  /// An output bytestream.\n  ///\n  /// `output-stream`s are *non-blocking* to the extent practical on\n  /// underlying platforms. Except where specified otherwise, I/O operations also\n  /// always return promptly, after the number of bytes that can be written\n  /// promptly, which could even be zero. To wait for the stream to be ready to\n  /// accept data, the `subscribe` function to obtain a `pollable` which can be\n  /// polled for using `wasi:io/poll`.\n  resource output-stream {\n    /// Check readiness for writing. This function never blocks.\n    ///\n    /// Returns the number of bytes permitted for the next call to `write`,\n    /// or an error. Calling `write` with more bytes than this function has\n    /// permitted will trap.\n    ///\n    /// When this function returns 0 bytes, the `subscribe` pollable will\n    /// become ready when this function will report at least 1 byte, or an\n    /// error.\n    check-write: func() -> result<u64, stream-error>;\n    /// Perform a write. This function never blocks.\n    ///\n    /// When the destination of a `write` is binary data, the bytes from\n    /// `contents` are written verbatim. When the destination of a `write` is\n    /// known to the implementation to be text, the bytes of `contents` are\n    /// transcoded from UTF-8 into the encoding of the destination and then\n    /// written.\n    ///\n    /// Precondition: check-write gave permit of Ok(n) and contents has a\n    /// length of less than or equal to n. Otherwise, this function will trap.\n    ///\n    /// returns Err(closed) without writing if the stream has closed since\n    /// the last call to check-write provided a permit.\n    write: func(contents: list<u8>) -> result<_, stream-error>;\n    /// Perform a write of up to 4096 bytes, and then flush the stream. Block\n    /// until all of these operations are complete, or an error occurs.\n    ///\n    /// This is a convenience wrapper around the use of `check-write`,\n    /// `subscribe`, `write`, and `flush`, and is implemented with the\n    /// following pseudo-code:\n    ///\n    /// ```text\n    /// let pollable = this.subscribe();\n    /// while !contents.is_empty() {\n    /// // Wait for the stream to become writable\n    /// pollable.block();\n    /// let Ok(n) = this.check-write(); // eliding error handling\n    /// let len = min(n, contents.len());\n    /// let (chunk, rest) = contents.split_at(len);\n    /// this.write(chunk  );            // eliding error handling\n    /// contents = rest;\n    /// }\n    /// this.flush();\n    /// // Wait for completion of `flush`\n    /// pollable.block();\n    /// // Check for any errors that arose during `flush`\n    /// let _ = this.check-write();         // eliding error handling\n    /// ```\n    blocking-write-and-flush: func(contents: list<u8>) -> result<_, stream-error>;\n    /// Request to flush buffered output. This function never blocks.\n    ///\n    /// This tells the output-stream that the caller intends any buffered\n    /// output to be flushed. the output which is expected to be flushed\n    /// is all that has been passed to `write` prior to this call.\n    ///\n    /// Upon calling this function, the `output-stream` will not accept any\n    /// writes (`check-write` will return `ok(0)`) until the flush has\n    /// completed. The `subscribe` pollable will become ready when the\n    /// flush has completed and the stream can accept more writes.\n    flush: func() -> result<_, stream-error>;\n    /// Request to flush buffered output, and block until flush completes\n    /// and stream is ready for writing again.\n    blocking-flush: func() -> result<_, stream-error>;\n    /// Create a `pollable` which will resolve once the output-stream\n    /// is ready for more writing, or an error has occured. When this\n    /// pollable is ready, `check-write` will return `ok(n)` with n>0, or an\n    /// error.\n    ///\n    /// If the stream is closed, this pollable is always ready immediately.\n    ///\n    /// The created `pollable` is a child resource of the `output-stream`.\n    /// Implementations may trap if the `output-stream` is dropped before\n    /// all derived `pollable`s created with this function are dropped.\n    subscribe: func() -> pollable;\n    /// Write zeroes to a stream.\n    ///\n    /// This should be used precisely like `write` with the exact same\n    /// preconditions (must use check-write first), but instead of\n    /// passing a list of bytes, you simply pass the number of zero-bytes\n    /// that should be written.\n    write-zeroes: func(len: u64) -> result<_, stream-error>;\n    /// Perform a write of up to 4096 zeroes, and then flush the stream.\n    /// Block until all of these operations are complete, or an error\n    /// occurs.\n    ///\n    /// This is a convenience wrapper around the use of `check-write`,\n    /// `subscribe`, `write-zeroes`, and `flush`, and is implemented with\n    /// the following pseudo-code:\n    ///\n    /// ```text\n    /// let pollable = this.subscribe();\n    /// while num_zeroes != 0 {\n    /// // Wait for the stream to become writable\n    /// pollable.block();\n    /// let Ok(n) = this.check-write(); // eliding error handling\n    /// let len = min(n, num_zeroes);\n    /// this.write-zeroes(len);         // eliding error handling\n    /// num_zeroes -= len;\n    /// }\n    /// this.flush();\n    /// // Wait for completion of `flush`\n    /// pollable.block();\n    /// // Check for any errors that arose during `flush`\n    /// let _ = this.check-write();         // eliding error handling\n    /// ```\n    blocking-write-zeroes-and-flush: func(len: u64) -> result<_, stream-error>;\n    /// Read from one stream and write to another.\n    ///\n    /// The behavior of splice is equivelant to:\n    /// 1. calling `check-write` on the `output-stream`\n    /// 2. calling `read` on the `input-stream` with the smaller of the\n    /// `check-write` permitted length and the `len` provided to `splice`\n    /// 3. calling `write` on the `output-stream` with that read data.\n    ///\n    /// Any error reported by the call to `check-write`, `read`, or\n    /// `write` ends the splice and reports that error.\n    ///\n    /// This function returns the number of bytes transferred; it may be less\n    /// than `len`.\n    splice: func(src: borrow<input-stream>, len: u64) -> result<u64, stream-error>;\n    /// Read from one stream and write to another, with blocking.\n    ///\n    /// This is similar to `splice`, except that it blocks until the\n    /// `output-stream` is ready for writing, and the `input-stream`\n    /// is ready for reading, before performing the `splice`.\n    blocking-splice: func(src: borrow<input-stream>, len: u64) -> result<u64, stream-error>;\n  }\n}\n\nworld imports {\n  import error;\n  import poll;\n  import streams;\n}\n";
const _: &[u8] = b"package wasi:random@0.2.0;\n\ninterface random {\n  get-random-bytes: func(len: u64) -> list<u8>;\n\n  get-random-u64: func() -> u64;\n}\n\ninterface insecure {\n  get-insecure-random-bytes: func(len: u64) -> list<u8>;\n\n  get-insecure-random-u64: func() -> u64;\n}\n\ninterface insecure-seed {\n  insecure-seed: func() -> tuple<u64, u64>;\n}\n\n";
const _: &[u8] = b"package wasi:sockets@0.2.0;\n\ninterface network {\n  resource network;\n\n  enum error-code {\n    unknown,\n    access-denied,\n    not-supported,\n    invalid-argument,\n    out-of-memory,\n    timeout,\n    concurrency-conflict,\n    not-in-progress,\n    would-block,\n    invalid-state,\n    new-socket-limit,\n    address-not-bindable,\n    address-in-use,\n    remote-unreachable,\n    connection-refused,\n    connection-reset,\n    connection-aborted,\n    datagram-too-large,\n    name-unresolvable,\n    temporary-resolver-failure,\n    permanent-resolver-failure,\n  }\n\n  enum ip-address-family {\n    ipv4,\n    ipv6,\n  }\n\n  type ipv4-address = tuple<u8, u8, u8, u8>;\n\n  type ipv6-address = tuple<u16, u16, u16, u16, u16, u16, u16, u16>;\n\n  variant ip-address {\n    ipv4(ipv4-address),\n    ipv6(ipv6-address),\n  }\n\n  record ipv4-socket-address {\n    port: u16,\n    address: ipv4-address,\n  }\n\n  record ipv6-socket-address {\n    port: u16,\n    flow-info: u32,\n    address: ipv6-address,\n    scope-id: u32,\n  }\n\n  variant ip-socket-address {\n    ipv4(ipv4-socket-address),\n    ipv6(ipv6-socket-address),\n  }\n}\n\ninterface instance-network {\n  use network.{network};\n\n  instance-network: func() -> network;\n}\n\ninterface udp {\n  use wasi:io/poll@0.2.0.{pollable};\n  use network.{network, error-code, ip-socket-address, ip-address-family};\n\n  record incoming-datagram {\n    data: list<u8>,\n    remote-address: ip-socket-address,\n  }\n\n  record outgoing-datagram {\n    data: list<u8>,\n    remote-address: option<ip-socket-address>,\n  }\n\n  resource udp-socket {\n    start-bind: func(network: borrow<network>, local-address: ip-socket-address) -> result<_, error-code>;\n    finish-bind: func() -> result<_, error-code>;\n    %stream: func(remote-address: option<ip-socket-address>) -> result<tuple<incoming-datagram-stream, outgoing-datagram-stream>, error-code>;\n    local-address: func() -> result<ip-socket-address, error-code>;\n    remote-address: func() -> result<ip-socket-address, error-code>;\n    address-family: func() -> ip-address-family;\n    unicast-hop-limit: func() -> result<u8, error-code>;\n    set-unicast-hop-limit: func(value: u8) -> result<_, error-code>;\n    receive-buffer-size: func() -> result<u64, error-code>;\n    set-receive-buffer-size: func(value: u64) -> result<_, error-code>;\n    send-buffer-size: func() -> result<u64, error-code>;\n    set-send-buffer-size: func(value: u64) -> result<_, error-code>;\n    subscribe: func() -> pollable;\n  }\n\n  resource incoming-datagram-stream {\n    receive: func(max-results: u64) -> result<list<incoming-datagram>, error-code>;\n    subscribe: func() -> pollable;\n  }\n\n  resource outgoing-datagram-stream {\n    check-send: func() -> result<u64, error-code>;\n    send: func(datagrams: list<outgoing-datagram>) -> result<u64, error-code>;\n    subscribe: func() -> pollable;\n  }\n}\n\ninterface udp-create-socket {\n  use network.{network, error-code, ip-address-family};\n  use udp.{udp-socket};\n\n  create-udp-socket: func(address-family: ip-address-family) -> result<udp-socket, error-code>;\n}\n\ninterface tcp {\n  use wasi:io/streams@0.2.0.{input-stream, output-stream};\n  use wasi:io/poll@0.2.0.{pollable};\n  use wasi:clocks/monotonic-clock@0.2.0.{duration};\n  use network.{network, error-code, ip-socket-address, ip-address-family};\n\n  enum shutdown-type {\n    receive,\n    send,\n    both,\n  }\n\n  resource tcp-socket {\n    start-bind: func(network: borrow<network>, local-address: ip-socket-address) -> result<_, error-code>;\n    finish-bind: func() -> result<_, error-code>;\n    start-connect: func(network: borrow<network>, remote-address: ip-socket-address) -> result<_, error-code>;\n    finish-connect: func() -> result<tuple<input-stream, output-stream>, error-code>;\n    start-listen: func() -> result<_, error-code>;\n    finish-listen: func() -> result<_, error-code>;\n    accept: func() -> result<tuple<tcp-socket, input-stream, output-stream>, error-code>;\n    local-address: func() -> result<ip-socket-address, error-code>;\n    remote-address: func() -> result<ip-socket-address, error-code>;\n    is-listening: func() -> bool;\n    address-family: func() -> ip-address-family;\n    set-listen-backlog-size: func(value: u64) -> result<_, error-code>;\n    keep-alive-enabled: func() -> result<bool, error-code>;\n    set-keep-alive-enabled: func(value: bool) -> result<_, error-code>;\n    keep-alive-idle-time: func() -> result<duration, error-code>;\n    set-keep-alive-idle-time: func(value: duration) -> result<_, error-code>;\n    keep-alive-interval: func() -> result<duration, error-code>;\n    set-keep-alive-interval: func(value: duration) -> result<_, error-code>;\n    keep-alive-count: func() -> result<u32, error-code>;\n    set-keep-alive-count: func(value: u32) -> result<_, error-code>;\n    hop-limit: func() -> result<u8, error-code>;\n    set-hop-limit: func(value: u8) -> result<_, error-code>;\n    receive-buffer-size: func() -> result<u64, error-code>;\n    set-receive-buffer-size: func(value: u64) -> result<_, error-code>;\n    send-buffer-size: func() -> result<u64, error-code>;\n    set-send-buffer-size: func(value: u64) -> result<_, error-code>;\n    subscribe: func() -> pollable;\n    shutdown: func(shutdown-type: shutdown-type) -> result<_, error-code>;\n  }\n}\n\ninterface tcp-create-socket {\n  use network.{network, error-code, ip-address-family};\n  use tcp.{tcp-socket};\n\n  create-tcp-socket: func(address-family: ip-address-family) -> result<tcp-socket, error-code>;\n}\n\ninterface ip-name-lookup {\n  use wasi:io/poll@0.2.0.{pollable};\n  use network.{network, error-code, ip-address};\n\n  resource resolve-address-stream {\n    resolve-next-address: func() -> result<option<ip-address>, error-code>;\n    subscribe: func() -> pollable;\n  }\n\n  resolve-addresses: func(network: borrow<network>, name: string) -> result<resolve-address-stream, error-code>;\n}\n\n";
use exports::tangent::logs::mapper::{Guest, Meta, Pred, Selector};
use tangent::logs::log::{Logview, Scalar};
struct Component;
const _: () = {
    #[unsafe(export_name = "tangent:logs/mapper@0.1.0#metadata")]
    unsafe extern "C" fn export_metadata() -> *mut u8 {
        unsafe {
            self::exports::tangent::logs::mapper::_export_metadata_cabi::<Component>()
        }
    }
    #[unsafe(export_name = "cabi_post_tangent:logs/mapper@0.1.0#metadata")]
    unsafe extern "C" fn _post_return_metadata(arg0: *mut u8) {
        unsafe {
            self::exports::tangent::logs::mapper::__post_return_metadata::<
                Component,
            >(arg0)
        }
    }
    #[unsafe(export_name = "tangent:logs/mapper@0.1.0#probe")]
    unsafe extern "C" fn export_probe() -> *mut u8 {
        unsafe {
            self::exports::tangent::logs::mapper::_export_probe_cabi::<Component>()
        }
    }
    #[unsafe(export_name = "cabi_post_tangent:logs/mapper@0.1.0#probe")]
    unsafe extern "C" fn _post_return_probe(arg0: *mut u8) {
        unsafe {
            self::exports::tangent::logs::mapper::__post_return_probe::<Component>(arg0)
        }
    }
    #[unsafe(export_name = "tangent:logs/mapper@0.1.0#process-logs")]
    unsafe extern "C" fn export_process_logs(arg0: *mut u8, arg1: usize) -> *mut u8 {
        unsafe {
            self::exports::tangent::logs::mapper::_export_process_logs_cabi::<
                Component,
            >(arg0, arg1)
        }
    }
    #[unsafe(export_name = "cabi_post_tangent:logs/mapper@0.1.0#process-logs")]
    unsafe extern "C" fn _post_return_process_logs(arg0: *mut u8) {
        unsafe {
            self::exports::tangent::logs::mapper::__post_return_process_logs::<
                Component,
            >(arg0)
        }
    }
};
struct ExampleOutput {
    message: String,
    level: String,
    seen: i64,
    duration: f64,
    service: String,
    tags: Option<Vec<String>>,
}
#[automatically_derived]
impl ::core::default::Default for ExampleOutput {
    #[inline]
    fn default() -> ExampleOutput {
        ExampleOutput {
            message: ::core::default::Default::default(),
            level: ::core::default::Default::default(),
            seen: ::core::default::Default::default(),
            duration: ::core::default::Default::default(),
            service: ::core::default::Default::default(),
            tags: ::core::default::Default::default(),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for ExampleOutput {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private228::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "ExampleOutput",
                false as usize + 1 + 1 + 1 + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "message",
                &self.message,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "level",
                &self.level,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "seen",
                &self.seen,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "duration",
                &self.duration,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "service",
                &self.service,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "tags",
                &self.tags,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
fn string_from_scalar(s: Scalar) -> Option<String> {
    match s {
        Scalar::Str(v) => Some(v),
        _ => None,
    }
}
fn int_from_scalar(s: Scalar) -> Option<i64> {
    match s {
        Scalar::Int(v) => Some(v),
        _ => None,
    }
}
fn float_from_scalar(s: Scalar) -> Option<f64> {
    match s {
        Scalar::Float(v) => Some(v),
        _ => None,
    }
}
impl Guest for Component {
    fn metadata() -> Meta {
        Meta {
            name: "rust".to_string(),
            version: "0.1.0".to_string(),
        }
    }
    fn probe() -> Vec<Selector> {
        <[_]>::into_vec(
            ::alloc::boxed::box_new([
                Selector {
                    any: Vec::new(),
                    all: <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            Pred::Eq((
                                "source.name".to_string(),
                                Scalar::Str("myservice".to_string()),
                            )),
                        ]),
                    ),
                    none: Vec::new(),
                },
            ]),
        )
    }
    fn process_logs(input: Vec<&Logview>) -> Result<Vec<u8>, String> {
        let mut buf = Vec::new();
        for lv in input {
            let mut out = ExampleOutput::default();
            if let Some(val) = lv.get("msg").and_then(string_from_scalar) {
                out.message = val;
            }
            if let Some(val) = lv.get("msg.level").and_then(string_from_scalar) {
                out.level = val;
            }
            if let Some(val) = lv.get("seen").and_then(int_from_scalar) {
                out.seen = val;
            }
            if let Some(val) = lv.get("duration").and_then(float_from_scalar) {
                out.duration = val;
            }
            if let Some(val) = lv.get("source.name").and_then(string_from_scalar) {
                out.service = val;
            }
            if let Some(items) = lv.get_list("tags") {
                let mut tags = Vec::with_capacity(items.len());
                for item in items {
                    if let Scalar::Str(val) = item {
                        tags.push(val);
                    }
                }
                if !tags.is_empty() {
                    out.tags = Some(tags);
                }
            }
            lv.ResourceDrop();
            let json_line = serde_json::to_vec(&out).map_err(|e| e.to_string())?;
            buf.extend(json_line);
            buf.push(b'\n');
        }
        Ok(buf)
    }
}
